{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/pedro/Documents/repos/gocase-exam/node_modules/vanilla-lazyload/dist/lazyload.min.js","webpack:///./modules/FixedElementClearance.js","webpack:///./modules/MenuToggle.js","webpack:///./modules/ExiaModal.js","webpack:////home/pedro/Documents/repos/gocase-exam/node_modules/ssr-window/dist/ssr-window.esm.js","webpack:////home/pedro/Documents/repos/gocase-exam/node_modules/dom7/dist/dom7.modular.js","webpack:////home/pedro/Documents/repos/gocase-exam/node_modules/swiper/dist/js/swiper.esm.js","webpack:///./modules/slides.js","webpack:///./modules/burger.js","webpack:///./_modules.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","e","_extends","assign","arguments","length","apply","this","_typeof","iterator","constructor","window","navigator","test","userAgent","document","createElement","elements_selector","container","threshold","thresholds","data_src","data_srcset","data_sizes","data_bg","class_loading","class_loaded","class_error","load_delay","auto_unobserve","callback_enter","callback_exit","callback_reveal","callback_loaded","callback_error","callback_finish","use_native","a","CustomEvent","detail","instance","createEvent","initCustomEvent","dispatchEvent","getAttribute","setAttribute","removeAttribute","u","f","_loadingCount","_elements","_settings","_","children","tagName","push","v","g","IMG","parentNode","forEach","IFRAME","VIDEO","load","h","classList","add","className","addEventListener","y","removeEventListener","E","w","target","remove","replace","RegExp","k","A","_observer","z","unobserve","L","clearTimeout","indexOf","I","filter","style","backgroundImage","concat","b","callback_set","O","IntersectionObserver","isIntersecting","intersectionRatio","setTimeout","x","root","rootMargin","N","C","querySelectorAll","Array","slice","M","update","HTMLImageElement","observe","loadAll","destroy","lazyLoadOptions","undefined","FixedElementClearance","config","_classCallCheck","Error","element","CSSVariableName","elementHeights","calculatedHeight","calculateElementHeightArray","updateHeaderHeightCSSVariable","recalculateOnResize","documentElement","setProperty","_this","from","map","item","offsetHeight","Math","max","_toConsumableArray","height","_this2","MenuToggle","MenuToggle_classCallCheck","menuToggle","flattenSelectors","menuClose","menuElement","querySelector","activeClass","activeBodyClass","breakpointToHide","run","preventDefault","toggleBodyClass","toggleMenuActiveClass","hideOnBreakpoint","selectorArray","flattenedSelectors","itemLength","body","toggle","innerWidth","removeMenuActiveClass","removeBodyClass","ExiaModal","configObject","ExiaModal_classCallCheck","exiaModals","exiaModalOpen","bodyClass","main","openOnClick","dismissOnEscPress","dismissModalOnClick","modalName","addBodyClass","modalItem","triggerElement","modalCollection","modalOpenItem","modalIdToOpen","dataset","modalOpen","keyCode","removesbodyClass","_this3","ExiaModal_toConsumableArray","triggerElements","triggerElementItem","getElementWithAttribute","doc","activeElement","blur","nodeName","getElementById","initEvent","childNodes","getElementsByTagName","location","hash","win","history","getComputedStyle","getPropertyValue","Image","Date","screen","Dom7","[object Object]","arr","self","$","selector","context","els","tempParent","html","trim","toCreate","innerHTML","match","split","nodeType","unique","uniqueArray","fn","Class","Methods","addClass","classes","j","removeClass","hasClass","contains","toggleClass","attr","attrs","attrName","removeAttr","data","el","dom7ElementDataStorage","dataKey","transform","elStyle","webkitTransform","transition","duration","webkitTransitionDuration","transitionDuration","on","args","eventType","targetSelector","listener","capture","handleLiveEvent","eventData","dom7EventData","unshift","is","parents","handleEvent","events","event","dom7LiveListeners","proxyListener","dom7Listeners","off","handlers","handler","splice","dom7proxy","trigger","evt","bubbles","cancelable","dataIndex","transitionEnd","callback","dom","fireCallBack","outerWidth","includeMargins","styles","offsetWidth","parseFloat","outerHeight","offset","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","top","left","css","props","prop","each","text","textContent","compareWith","matches","webkitMatchesSelector","msMatchesSelector","index","child","previousSibling","eq","returnIndex","append","newChild","tempDiv","firstChild","appendChild","prepend","insertBefore","next","nextElementSibling","nextAll","nextEls","prev","previousElementSibling","prevAll","prevEls","parent","closest","find","foundElements","found","removeChild","toAdd","keys","methodName","Utils","obj","nextTick","delay","now","axis","matrix","curTransform","transformMatrix","curStyle","WebKitCSSMatrix","join","MozTransform","OTransform","MsTransform","msTransform","toString","m41","m42","url","query","params","param","urlToParse","href","paramsPart","decodeURIComponent","isObject","to","nextSource","keysArray","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","extend","swiper_esm_Support","testDiv","touch","Modernizr","maxTouchPoints","DocumentTouch","pointerEvents","pointerEnabled","PointerEvent","prefixedPointerEvents","msPointerEnabled","transforms3d","csstransforms3d","flexbox","observer","passiveListener","supportsPassive","opts","gestures","swiper_esm_Browser","isIE","isEdge","isSafari","ua","toLowerCase","isUiWebView","SwiperClass","eventsListeners","eventName","priority","method","onceHandler","f7proxy","eventHandler","isArray","instanceParams","moduleName","modulesParams","moduleParams","modulePropName","moduleProp","moduleEventName","components","use","proto","static","install","installModule","updateSize","swiper","width","$el","clientWidth","clientHeight","isHorizontal","isVertical","parseInt","size","updateSlides","$wrapperEl","swiperSize","rtlTranslate","rtl","wrongRTL","isVirtual","virtual","enabled","previousSlidesLength","slides","slideClass","slidesLength","snapGrid","slidesGrid","slidesSizesGrid","offsetBefore","slidesOffsetBefore","offsetAfter","slidesOffsetAfter","previousSnapGridLength","previousSlidesGridLength","slidesNumberEvenToRows","slideSize","spaceBetween","slidePosition","prevSlideSize","virtualSize","marginLeft","marginTop","marginRight","marginBottom","slidesPerColumn","floor","ceil","slidesPerView","slidesPerColumnFill","slidesPerRow","numFullColumns","slide","newSlideOrderIndex","column","row","-webkit-box-ordinal-group","-moz-box-ordinal-group","-ms-flex-order","-webkit-order","order","slideStyles","currentTransform","currentWebKitTransform","roundLengths","paddingLeft","paddingRight","boxSizing","paddingTop","paddingBottom","swiperSlideSize","centeredSlides","abs","slidesPerGroup","newSlidesGrid","effect","setWrapperSize","slidesGridItem","centerInsufficientSlides","allSlidesSize","slideSizeValue","allSlidesOffset","snap","snapIndex","emit","watchOverflow","checkOverflow","watchSlidesProgress","watchSlidesVisibility","updateSlidesOffset","updateAutoHeight","speed","activeSlides","newHeight","setTransition","activeIndex","swiperSlideOffset","offsetLeft","offsetTop","updateSlidesProgress","translate","offsetCenter","slideVisibleClass","visibleSlidesIndexes","visibleSlides","slideProgress","minTranslate","slideBefore","slideAfter","progress","updateProgress","translatesDiff","maxTranslate","isBeginning","isEnd","wasBeginning","wasEnd","updateSlidesClasses","realIndex","activeSlide","slideActiveClass","slideNextClass","slidePrevClass","slideDuplicateActiveClass","slideDuplicateNextClass","slideDuplicatePrevClass","loop","slideDuplicateClass","nextSlide","prevSlide","updateActiveIndex","newActiveIndex","previousIndex","previousRealIndex","previousSnapIndex","normalizeSlideIndex","updateClickedSlide","slideFound","clickedSlide","clickedIndex","slideToClickedSlide","swiper_esm_translate","getTranslate","virtualTranslate","currentTranslate","setTranslate","byController","newProgress","previousTranslate","swiper_esm_transition","transitionStart","runCallbacks","direction","autoHeight","dir","animating","swiper_esm_slide","slideTo","internal","slideIndex","preventInteractionOnTransition","initialSlide","initialized","allowSlideNext","allowSlidePrev","onSlideToWrapperTransitionEnd","destroyed","slideToLoop","newIndex","loopedSlides","slideNext","loopFix","_clientLeft","slidePrev","normalize","val","normalizedTranslate","normalizedSnapGrid","prevSnap","prevIndex","slideReset","slideToClosest","currentSnap","slidesPerViewDynamic","slideToIndex","loopCreate","loopFillGroupWithBlank","blankSlidesNum","blankNode","slideBlankClass","loopAdditionalSlides","prependSlides","appendSlides","cloneNode","diff","loopDestroy","grabCursor","setGrabCursor","moving","simulateTouch","isLocked","cursor","unsetGrabCursor","manipulation","appendSlide","prependSlide","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","swiper_esm_Device","device","ios","android","androidChrome","desktop","windows","iphone","ipod","ipad","cordova","phonegap","os","osVersion","webView","osVersionArr","metaViewport","minimalUi","pixelRatio","devicePixelRatio","onResize","breakpoints","setBreakpoint","freeMode","newTranslate","min","defaults","init","touchEventsTarget","edgeSwipeDetection","edgeSwipeThreshold","freeModeMomentum","freeModeMomentumRatio","freeModeMomentumBounce","freeModeMomentumBounceRatio","freeModeMomentumVelocityRatio","freeModeSticky","freeModeMinimumVelocity","breakpointsInverse","touchRatio","touchAngle","shortSwipes","longSwipes","longSwipesRatio","longSwipesMs","followFinger","allowTouchMove","touchMoveStopPropagation","touchStartPreventDefault","touchStartForcePreventDefault","touchReleaseOnEdges","uniqueNavElements","resistance","resistanceRatio","preventClicks","preventClicksPropagation","preloadImages","updateOnImagesReady","swipeHandler","noSwiping","noSwipingClass","noSwipingSelector","passiveListeners","containerModifierClass","wrapperClass","runCallbacksOnInit","prototypes","attachEvents","touchEvents","wrapperEl","onTouchStart","touchEventsData","touches","originalEvent","isTouchEvent","type","which","button","isTouched","isMoved","allowClick","currentX","targetTouches","pageX","currentY","pageY","startX","startY","iOSEdgeSwipeDetection","iOSEdgeSwipeThreshold","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","swipeDirection","allowThresholdMove","formElements","shouldPreventDefault","onTouchMove","preventedByNestedSwiper","diffX","diffY","sqrt","atan2","PI","nested","stopPropagation","startTranslate","allowMomentumBounce","disableParentSwiper","velocities","position","time","onTouchEnd","touchEndTime","timeDiff","lastClickTime","clickTimeout","currentPos","lastMoveEvent","pop","velocityEvent","distance","velocity","momentumDuration","momentumDistance","newPosition","afterBouncePosition","doBounce","bounceAmount","needsLoopFix","once","stopIndex","groupSize","ratio","onClick","stopImmediatePropagation","start","passive","move","end","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointOnlyParams","paramValue","breakpointParams","originalParams","directionChanged","needsReLoop","changeDirection","points","point","sort","wasLocked","navigation","addClasses","classNames","suffixes","suffix","removeClasses","images","loadImage","imageEl","src","srcset","sizes","checkForComplete","image","onReady","complete","onload","onerror","imagesLoaded","imagesToLoad","currentSrc","extendedDefaults","swiper_esm_Swiper","super","prototypeGroup","protoMethod","moduleParamName","swiperParams","useModulesParams","passedParams","swipers","containerEl","newParams","touchEventsTouch","touchEventsDesktop","useModules","spv","breakLoop","translateValue","translated","newDirection","needUpdate","currentDirection","slideEl","deleteInstance","cleanStyles","deleteProps","newDefaults","Device$1","Support$1","support","Browser$1","browser","Resize","resize","resizeHandler","orientationChangeHandler","Observer","func","MutationObserver","WebkitMutationObserver","options","ObserverFunc","mutations","observerUpdate","requestAnimationFrame","attributes","childList","characterData","observers","observeParents","containerParents","attach","observeSlideChildren","disconnect","Observer$1","Mousewheel","lastScrollTime","isSupported","implementation","hasFeature","isEventSupported","sX","sY","pX","pY","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","mouseEntered","mousewheel","releaseOnEdges","delta","rtlFactor","forceToAxis","invert","sensitivity","timeout","autoplay","autoplayDisableOnInteraction","stop","getTime","returnValue","eventsTarged","handleMouseEnter","handleMouseLeave","handle","Navigation","$nextEl","$prevEl","disabledClass","lockClass","nextEl","prevEl","onNextClick","onPrevClick","hideOnClick","hiddenClass","isHidden","Pagination","pagination","current","total","paginationType","bullets","firstIndex","lastIndex","midIndex","dynamicBullets","bulletSize","dynamicMainBullets","dynamicBulletIndex","bulletActiveClass","bullet","$bullet","bulletIndex","$firstDisplayedBullet","$lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","offsetProp","currentClass","formatFractionCurrent","totalClass","formatFractionTotal","progressbarDirection","progressbarOpposite","scale","scaleX","scaleY","progressbarFillClass","renderCustom","paginationHTML","numberOfBullets","renderBullet","bulletClass","bulletElement","renderFraction","renderProgressbar","clickable","clickableClass","modifierClass","progressbarOppositeClass","number","render","Swiper","burgerIcons","500","600","800","900","LazyLoad","Modal"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","function _extends(){return(_extends=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}function _typeof(t){return(_typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}!function(t,e){\"object\"===(\"undefined\"==typeof exports?\"undefined\":_typeof(exports))&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.LazyLoad=e()}(this,function(){\"use strict\";var t=\"undefined\"!=typeof window,e=t&&!(\"onscroll\"in window)||\"undefined\"!=typeof navigator&&/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),n=t&&\"IntersectionObserver\"in window,o=t&&\"classList\"in document.createElement(\"p\"),r={elements_selector:\"img\",container:e||t?document:null,threshold:300,thresholds:null,data_src:\"src\",data_srcset:\"srcset\",data_sizes:\"sizes\",data_bg:\"bg\",class_loading:\"loading\",class_loaded:\"loaded\",class_error:\"error\",load_delay:0,auto_unobserve:!0,callback_enter:null,callback_exit:null,callback_reveal:null,callback_loaded:null,callback_error:null,callback_finish:null,use_native:!1},a=function(t,e){var n,o=new t(e);try{n=new CustomEvent(\"LazyLoad::Initialized\",{detail:{instance:o}})}catch(t){(n=document.createEvent(\"CustomEvent\")).initCustomEvent(\"LazyLoad::Initialized\",!1,!1,{instance:o})}window.dispatchEvent(n)};var i=function(t,e){return t.getAttribute(\"data-\"+e)},s=function(t,e,n){var o=\"data-\"+e;null!==n?t.setAttribute(o,n):t.removeAttribute(o)},c=function(t){return\"true\"===i(t,\"was-processed\")},l=function(t,e){return s(t,\"ll-timeout\",e)},u=function(t){return i(t,\"ll-timeout\")},d=function(t,e){t&&t(e)},f=function(t,e){t._loadingCount+=e,0===t._elements.length&&0===t._loadingCount&&d(t._settings.callback_finish)},_=function(t){for(var e,n=[],o=0;e=t.children[o];o+=1)\"SOURCE\"===e.tagName&&n.push(e);return n},v=function(t,e,n){n&&t.setAttribute(e,n)},g=function(t,e){v(t,\"sizes\",i(t,e.data_sizes)),v(t,\"srcset\",i(t,e.data_srcset)),v(t,\"src\",i(t,e.data_src))},m={IMG:function(t,e){var n=t.parentNode;n&&\"PICTURE\"===n.tagName&&_(n).forEach(function(t){g(t,e)});g(t,e)},IFRAME:function(t,e){v(t,\"src\",i(t,e.data_src))},VIDEO:function(t,e){_(t).forEach(function(t){v(t,\"src\",i(t,e.data_src))}),v(t,\"src\",i(t,e.data_src)),t.load()}},b=function(t,e){var n,o,r=e._settings,a=t.tagName,s=m[a];if(s)return s(t,r),f(e,1),void(e._elements=(n=e._elements,o=t,n.filter(function(t){return t!==o})));!function(t,e){var n=i(t,e.data_src),o=i(t,e.data_bg);n&&(t.style.backgroundImage='url(\"'.concat(n,'\")')),o&&(t.style.backgroundImage=o)}(t,r)},h=function(t,e){o?t.classList.add(e):t.className+=(t.className?\" \":\"\")+e},p=function(t,e,n){t.addEventListener(e,n)},y=function(t,e,n){t.removeEventListener(e,n)},E=function(t,e,n){y(t,\"load\",e),y(t,\"loadeddata\",e),y(t,\"error\",n)},w=function(t,e,n){var r=n._settings,a=e?r.class_loaded:r.class_error,i=e?r.callback_loaded:r.callback_error,s=t.target;!function(t,e){o?t.classList.remove(e):t.className=t.className.replace(new RegExp(\"(^|\\\\s+)\"+e+\"(\\\\s+|$)\"),\" \").replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")}(s,r.class_loading),h(s,a),d(i,s),f(n,-1)},I=function(t,e){var n=function n(r){w(r,!0,e),E(t,n,o)},o=function o(r){w(r,!1,e),E(t,n,o)};!function(t,e,n){p(t,\"load\",e),p(t,\"loadeddata\",e),p(t,\"error\",n)}(t,n,o)},k=[\"IMG\",\"IFRAME\",\"VIDEO\"],A=function(t,e){var n=e._observer;z(t,e),n&&e._settings.auto_unobserve&&n.unobserve(t)},L=function(t){var e=u(t);e&&(clearTimeout(e),l(t,null))},x=function(t,e){var n=e._settings.load_delay,o=u(t);o||(o=setTimeout(function(){A(t,e),L(t)},n),l(t,o))},z=function(t,e,n){var o=e._settings;!n&&c(t)||(k.indexOf(t.tagName)>-1&&(I(t,e),h(t,o.class_loading)),b(t,e),function(t){s(t,\"was-processed\",\"true\")}(t),d(o.callback_reveal,t),d(o.callback_set,t))},O=function(t){return!!n&&(t._observer=new IntersectionObserver(function(e){e.forEach(function(e){return function(t){return t.isIntersecting||t.intersectionRatio>0}(e)?function(t,e){var n=e._settings;d(n.callback_enter,t),n.load_delay?x(t,e):A(t,e)}(e.target,t):function(t,e){var n=e._settings;d(n.callback_exit,t),n.load_delay&&L(t)}(e.target,t)})},{root:(e=t._settings).container===document?null:e.container,rootMargin:e.thresholds||e.threshold+\"px\"}),!0);var e},N=[\"IMG\",\"IFRAME\"],C=function(t,e){return function(t){return t.filter(function(t){return!c(t)})}((n=t||function(t){return t.container.querySelectorAll(t.elements_selector)}(e),Array.prototype.slice.call(n)));var n},M=function(t,e){this._settings=function(t){return _extends({},r,t)}(t),this._loadingCount=0,O(this),this.update(e)};return M.prototype={update:function(t){var n,o=this,r=this._settings;(this._elements=C(t,r),!e&&this._observer)?(function(t){return t.use_native&&\"loading\"in HTMLImageElement.prototype}(r)&&((n=this)._elements.forEach(function(t){-1!==N.indexOf(t.tagName)&&(t.setAttribute(\"loading\",\"lazy\"),z(t,n))}),this._elements=C(t,r)),this._elements.forEach(function(t){o._observer.observe(t)})):this.loadAll()},destroy:function(){var t=this;this._observer&&(this._elements.forEach(function(e){t._observer.unobserve(e)}),this._observer=null),this._elements=null,this._settings=null},load:function(t,e){z(t,this,e)},loadAll:function(){var t=this;this._elements.forEach(function(e){A(e,t)})}},t&&function(t,e){if(e)if(e.length)for(var n,o=0;n=e[o];o+=1)a(t,n);else a(t,e)}(M,window.lazyLoadOptions),M});\n//# sourceMappingURL=lazyload.min.js.map\n","/**\n * Fixed Element Clearance\n * Armazena a altura de elementos do DOM em uma variável CSS\n *\n * @version 0.2.0\n * @author Pedro Britto <pedroivobritto@gmail.com>\n */\n\nexport default class FixedElementClearance {\n    constructor(config) {\n        if (!config) {\n            throw Error(\"No config object privided.\");\n        }\n\n        if (typeof config.element != \"string\") {\n            throw Error(\"config.element should be a string.\");\n        }\n\n        if (typeof config.CSSVariableName != \"string\") {\n            throw Error(\"config.CSSVariableName should be a string.\");\n        }\n\n        this.element = document.querySelectorAll(config.element);\n        this.CSSVariableName = config.CSSVariableName\n            ? config.CSSVariableName\n            : \"fixed-element-clearance\";\n\n        if (this.element.length === 0) {\n            document.documentElement.style.setProperty(`--${this.CSSVariableName}`, `0px`);\n\n            return;\n        }\n\n        this.elementHeights = [];\n        this.calculatedHeight;\n\n        this.calculateElementHeightArray();\n        this.updateHeaderHeightCSSVariable(this.calculatedHeight);\n        this.recalculateOnResize();\n    }\n\n    /**\n     * Atualiza alturas no array\n     */\n    calculateElementHeightArray() {\n        this.elementHeights = [];\n\n        Array.from(this.element).map(item => this.elementHeights.push(item.offsetHeight));\n\n        this.calculatedHeight = Math.max(...this.elementHeights);\n        return this.calculatedHeight;\n    }\n\n    /**\n     * Atualiza variável CSS com altura máxima\n     */\n    updateHeaderHeightCSSVariable(height) {\n        return document.documentElement.style.setProperty(\n            `--${this.CSSVariableName}`,\n            `${height}px`\n        );\n    }\n\n    /**\n     * Recalcula alturas no resize\n     */\n    recalculateOnResize() {\n        window.addEventListener(\"resize\", () => {\n            this.calculatedHeight = this.element.offsetHeight;\n            this.calculateElementHeightArray();\n            this.updateHeaderHeightCSSVariable(this.calculatedHeight);\n        });\n    }\n}\n","/**\n * Menu Toggle\n *\n * Adiciona e Remove classe \"is-active\" em um elemento a partir do clique em outro.\n *\n * @version 0.4.0\n * @author Pedro Britto <pedroivobritto@gmail.com>\n */\nexport default class MenuToggle {\n    /**\n     * @constructor\n     * @param {*} config Objeto de configuração que aceita as seguintes propriedades:\n     * @param {string[]} config.menuToggle Elemento que quando clicado ativa o menu (menuElement).\n     * @param {string} config.menuElement Elemento ativado quando menuToggle é clicado.\n     * @param {string[]} config.menuClose Elemento que desativa o menu (menuElement) quando clicado.\n     * @param {string} [config.activeClass] Nome da classe adicionada ao menuElement.\n     *  Padrão: is-active.\n     * @param {string} [config.activeBodyClass] Classe adicionada ao body quando menuToggle é clicado.\n     *  Padrão: undefined.\n     * @param {number} [config.breakpointToHide] Largura (px) para remover activeClass de menuElement.\n     */\n    constructor(config) {\n        if (!config || typeof config != \"object\") {\n            throw new Error(\"Menu Toggle config must be an object.\");\n        }\n\n        if (config.menuToggle) {\n            this.menuToggle = this.flattenSelectors(config.menuToggle);\n        }\n\n        if (config.menuClose) {\n            this.menuClose = this.flattenSelectors(config.menuClose);\n        }\n\n        this.menuElement = document.querySelector(config.menuElement);\n        this.activeClass = config.activeClass ? config.activeClass : \"is-active\";\n        this.activeBodyClass = config.activeBodyClass ? config.activeBodyClass : null;\n        this.breakpointToHide = config.breakpointToHide ? config.breakpointToHide : null;\n\n        this.run();\n    }\n\n    run() {\n        this.menuToggle.map(item => {\n            if (!item) {\n                return;\n            }\n\n            item.addEventListener(\"click\", e => {\n                e.preventDefault();\n\n                if (this.activeBodyClass) {\n                    this.toggleBodyClass();\n                }\n\n                this.toggleMenuActiveClass();\n            });\n\n            if (this.breakpointToHide) {\n                this.hideOnBreakpoint(this.breakpointToHide);\n            }\n        });\n\n        this.menuClose.map(item => {\n            if (!item) {\n                return;\n            }\n\n            item.addEventListener(\"click\", () => {\n                if (this.activeBodyClass) {\n                    this.toggleBodyClass();\n                }\n\n                this.toggleMenuActiveClass();\n            });\n        });\n    }\n\n    flattenSelectors(selectorArray) {\n        const flattenedSelectors = [];\n        const allElements = selectorArray.map(item => document.querySelectorAll(item));\n\n        allElements.map(item => {\n            if (item.length > 0) {\n                let itemLength = item.length;\n\n                for (let i = 0; i < itemLength; i++) {\n                    flattenedSelectors.push(item[i]);\n                }\n            }\n        });\n\n        return flattenedSelectors;\n    }\n\n    toggleBodyClass() {\n        return document.body.classList.toggle(this.activeBodyClass);\n    }\n\n    removeBodyClass() {\n        return document.body.classList.remove(this.activeBodyClass);\n    }\n\n    toggleMenuActiveClass() {\n        return this.menuElement.classList.toggle(this.activeClass);\n    }\n\n    removeMenuActiveClass() {\n        return this.menuElement.classList.remove(this.activeClass);\n    }\n\n    hideOnBreakpoint(breakpointToHide) {\n        if (window.innerWidth >= breakpointToHide) {\n            this.removeMenuActiveClass();\n            this.removeBodyClass();\n        }\n\n        window.addEventListener(\"resize\", () => {\n            if (window.innerWidth >= breakpointToHide) {\n                this.removeMenuActiveClass();\n                this.removeBodyClass();\n            }\n        });\n    }\n}\n","/**\n * Exia Modal\n *\n * @version 0.3.0\n * @author Pedro Britto <pedroivobritto@gmail.com>\n */\nexport default class ExiaModal {\n    /**\n     * @constructor\n     * @param {Object} configObject\n     */\n    constructor(configObject) {\n        this.exiaModals = document.querySelectorAll(\"[data-modal]\");\n        this.exiaModalOpen = document.querySelectorAll(\"[data-modal-open]\");\n\n        if (configObject) {\n            this.bodyClass = configObject.bodyClass ? configObject.bodyClass : \"is-scroll-locked\";\n        }\n\n        this.main();\n    }\n\n    main() {\n        this.openOnClick(this.exiaModalOpen, this.exiaModals);\n        this.dismissOnEscPress(this.exiaModals);\n        this.dismissModalOnClick(\".js-modal-close\", this.exiaModals);\n    }\n\n    /**\n     * Abre modal diretamente a partir do Id\n     *\n     * @param {string} modalName Id do modal a ser aberto\n     * @param {boolean} addBodyClass Add ou não a bodyClass em document.body\n     */\n    openModal(modalName, addBodyClass = true) {\n        this.exiaModals.map(modalItem => {\n            if (modalItem.getAttribute(\"data-modal\") == modalName)\n                modalItem.classList.add(\"is-visible\");\n        });\n\n        if (addBodyClass) {\n            this.addBodyClass(this.bodyClass);\n        }\n    }\n\n    /**\n     * Adiciona classe no <body> quando modal é ativado.\n     *\n     * @param {string} className Nome da classe\n     * @returns void\n     */\n    addBodyClass(className) {\n        if (className !== \"undefined\") document.body.classList.add(className);\n    }\n\n    /**\n     * Remove classe no <body> quando modal é dispensado.\n     *\n     * @param {string} className Nome da classe\n     * @returns void\n     */\n    removesbodyClass(className) {\n        document.body.classList.remove(className);\n    }\n\n    /**\n     * Abre modal quando o elemento especificado é clicado.\n     *\n     * @param {NodeList} triggerElement Elementos que ativam o modal\n     * @param {NodeList} modalCollection Coleção de modais\n     * @returns void\n     */\n    openOnClick(triggerElement, modalCollection) {\n        Array.from(triggerElement).map(modalOpenItem => {\n            modalOpenItem.addEventListener(\"click\", function() {\n                const modalIdToOpen = this.dataset.modalOpen;\n\n                Array.from(modalCollection).map(modalItem => {\n                    if (modalItem.getAttribute(\"data-modal\") == modalIdToOpen)\n                        modalItem.classList.add(\"is-visible\");\n                });\n            });\n\n            modalOpenItem.addEventListener(\"click\", () => {\n                this.addBodyClass(this.bodyClass);\n            });\n        });\n    }\n\n    /**\n     * Dispensa modal quando ESC é pressionado.\n     *\n     * @param {NodeList} modalCollection Coleção de modais\n     * @returns void\n     */\n    dismissOnEscPress(modalCollection) {\n        document.addEventListener(\"keydown\", e => {\n            if (e.keyCode === 27) {\n                Array.from(modalCollection).map(item => item.classList.remove(\"is-visible\"));\n                this.removesbodyClass(this.bodyClass);\n            }\n        });\n    }\n\n    /**\n     * Dispensa modal quando o elemento especificado é clicado.\n     *\n     * @param {string} triggerElement Seletor de um elemento html\n     * @param {NodeList} modalCollection Coleção de modais\n     * @returns void\n     */\n    dismissModalOnClick(triggerElement, modalCollection) {\n        [...modalCollection].map(item => {\n            const triggerElements = item.querySelectorAll(triggerElement);\n\n            Array.from(triggerElements).map(triggerElementItem => {\n                triggerElementItem.addEventListener(\"click\", () => {\n                    item.classList.remove(\"is-visible\");\n                    this.removesbodyClass(this.bodyClass);\n                });\n            });\n        });\n    }\n\n    /**\n     * Atualiza coleção de modais e triggers de modal e\n     * adiciona eventListener logo após.\n     *\n     * @returns void;\n     */\n    updateModalElements() {\n        this.exiaModals = this.getElementWithAttribute(\"data-modal\");\n        this.exiaModalOpen = this.getElementWithAttribute(\"data-modal-open\");\n\n        this.openOnClick(this.exiaModalOpen, this.exiaModals);\n    }\n}\n","/**\n * SSR Window 1.0.1\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2018, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: July 18, 2018\n */\nvar doc = (typeof document === 'undefined') ? {\n  body: {},\n  addEventListener: function addEventListener() {},\n  removeEventListener: function removeEventListener() {},\n  activeElement: {\n    blur: function blur() {},\n    nodeName: '',\n  },\n  querySelector: function querySelector() {\n    return null;\n  },\n  querySelectorAll: function querySelectorAll() {\n    return [];\n  },\n  getElementById: function getElementById() {\n    return null;\n  },\n  createEvent: function createEvent() {\n    return {\n      initEvent: function initEvent() {},\n    };\n  },\n  createElement: function createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute: function setAttribute() {},\n      getElementsByTagName: function getElementsByTagName() {\n        return [];\n      },\n    };\n  },\n  location: { hash: '' },\n} : document; // eslint-disable-line\n\nvar win = (typeof window === 'undefined') ? {\n  document: doc,\n  navigator: {\n    userAgent: '',\n  },\n  location: {},\n  history: {},\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener: function addEventListener() {},\n  removeEventListener: function removeEventListener() {},\n  getComputedStyle: function getComputedStyle() {\n    return {\n      getPropertyValue: function getPropertyValue() {\n        return '';\n      },\n    };\n  },\n  Image: function Image() {},\n  Date: function Date() {},\n  screen: {},\n  setTimeout: function setTimeout() {},\n  clearTimeout: function clearTimeout() {},\n} : window; // eslint-disable-line\n\nexport { win as window, doc as document };\n","/**\n * Dom7 2.1.3\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * http://framework7.io/docs/dom.html\n *\n * Copyright 2019, Vladimir Kharlampidi\n * The iDangero.us\n * http://www.idangero.us/\n *\n * Licensed under MIT\n *\n * Released on: February 11, 2019\n */\nimport { document, window } from 'ssr-window';\n\nclass Dom7 {\n  constructor(arr) {\n    const self = this;\n    // Create array-like object\n    for (let i = 0; i < arr.length; i += 1) {\n      self[i] = arr[i];\n    }\n    self.length = arr.length;\n    // Return collection with methods\n    return this;\n  }\n}\n\nfunction $(selector, context) {\n  const arr = [];\n  let i = 0;\n  if (selector && !context) {\n    if (selector instanceof Dom7) {\n      return selector;\n    }\n  }\n  if (selector) {\n      // String\n    if (typeof selector === 'string') {\n      let els;\n      let tempParent;\n      const html = selector.trim();\n      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n        let toCreate = 'div';\n        if (html.indexOf('<li') === 0) toCreate = 'ul';\n        if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n        if (html.indexOf('<tbody') === 0) toCreate = 'table';\n        if (html.indexOf('<option') === 0) toCreate = 'select';\n        tempParent = document.createElement(toCreate);\n        tempParent.innerHTML = html;\n        for (i = 0; i < tempParent.childNodes.length; i += 1) {\n          arr.push(tempParent.childNodes[i]);\n        }\n      } else {\n        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {\n          // Pure ID selector\n          els = [document.getElementById(selector.trim().split('#')[1])];\n        } else {\n          // Other selectors\n          els = (context || document).querySelectorAll(selector.trim());\n        }\n        for (i = 0; i < els.length; i += 1) {\n          if (els[i]) arr.push(els[i]);\n        }\n      }\n    } else if (selector.nodeType || selector === window || selector === document) {\n      // Node/element\n      arr.push(selector);\n    } else if (selector.length > 0 && selector[0].nodeType) {\n      // Array of elements or instance of Dom\n      for (i = 0; i < selector.length; i += 1) {\n        arr.push(selector[i]);\n      }\n    }\n  }\n  return new Dom7(arr);\n}\n\n$.fn = Dom7.prototype;\n$.Class = Dom7;\n$.Dom7 = Dom7;\n\nfunction unique(arr) {\n  const uniqueArray = [];\n  for (let i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n  }\n  return uniqueArray;\n}\nfunction toCamelCase(string) {\n  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());\n}\n\nfunction requestAnimationFrame(callback) {\n  if (window.requestAnimationFrame) return window.requestAnimationFrame(callback);\n  else if (window.webkitRequestAnimationFrame) return window.webkitRequestAnimationFrame(callback);\n  return window.setTimeout(callback, 1000 / 60);\n}\nfunction cancelAnimationFrame(id) {\n  if (window.cancelAnimationFrame) return window.cancelAnimationFrame(id);\n  else if (window.webkitCancelAnimationFrame) return window.webkitCancelAnimationFrame(id);\n  return window.clearTimeout(id);\n}\n\n// Classes and attributes\nfunction addClass(className) {\n  if (typeof className === 'undefined') {\n    return this;\n  }\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);\n    }\n  }\n  return this;\n}\nfunction removeClass(className) {\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);\n    }\n  }\n  return this;\n}\nfunction hasClass(className) {\n  if (!this[0]) return false;\n  return this[0].classList.contains(className);\n}\nfunction toggleClass(className) {\n  const classes = className.split(' ');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);\n    }\n  }\n  return this;\n}\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === 'string') {\n    // Get attr\n    if (this[0]) return this[0].getAttribute(attrs);\n    return undefined;\n  }\n\n  // Set attrs\n  for (let i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      // String\n      this[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      // eslint-disable-next-line\n      for (const attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction removeAttr(attr) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr);\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prop(props, value) {\n  if (arguments.length === 1 && typeof props === 'string') {\n    // Get prop\n    if (this[0]) return this[0][props];\n  } else {\n    // Set props\n    for (let i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i][props] = value;\n      } else {\n        // Object\n        // eslint-disable-next-line\n        for (const propName in props) {\n          this[i][propName] = props[propName];\n        }\n      }\n    }\n    return this;\n  }\n}\nfunction data(key, value) {\n  let el;\n  if (typeof value === 'undefined') {\n    el = this[0];\n    // Get value\n    if (el) {\n      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {\n        return el.dom7ElementDataStorage[key];\n      }\n\n      const dataKey = el.getAttribute(`data-${key}`);\n      if (dataKey) {\n        return dataKey;\n      }\n      return undefined;\n    }\n    return undefined;\n  }\n\n  // Set value\n  for (let i = 0; i < this.length; i += 1) {\n    el = this[i];\n    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};\n    el.dom7ElementDataStorage[key] = value;\n  }\n  return this;\n}\nfunction removeData(key) {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {\n      el.dom7ElementDataStorage[key] = null;\n      delete el.dom7ElementDataStorage[key];\n    }\n  }\n}\nfunction dataset() {\n  const el = this[0];\n  if (!el) return undefined;\n  const dataset = {}; // eslint-disable-line\n  if (el.dataset) {\n    // eslint-disable-next-line\n    for (const dataKey in el.dataset) {\n      dataset[dataKey] = el.dataset[dataKey];\n    }\n  } else {\n    for (let i = 0; i < el.attributes.length; i += 1) {\n      // eslint-disable-next-line\n      const attr = el.attributes[i];\n      if (attr.name.indexOf('data-') >= 0) {\n        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;\n      }\n    }\n  }\n  // eslint-disable-next-line\n  for (const key in dataset) {\n    if (dataset[key] === 'false') dataset[key] = false;\n    else if (dataset[key] === 'true') dataset[key] = true;\n    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;\n  }\n  return dataset;\n}\nfunction val(value) {\n  const dom = this;\n  if (typeof value === 'undefined') {\n    if (dom[0]) {\n      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {\n        const values = [];\n        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {\n          values.push(dom[0].selectedOptions[i].value);\n        }\n        return values;\n      }\n      return dom[0].value;\n    }\n    return undefined;\n  }\n\n  for (let i = 0; i < dom.length; i += 1) {\n    const el = dom[i];\n    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {\n      for (let j = 0; j < el.options.length; j += 1) {\n        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;\n      }\n    } else {\n      el.value = value;\n    }\n  }\n  return dom;\n}\n// Transforms\n// eslint-disable-next-line\nfunction transform(transform) {\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransform = transform;\n    elStyle.transform = transform;\n  }\n  return this;\n}\nfunction transition(duration) {\n  if (typeof duration !== 'string') {\n    duration = `${duration}ms`; // eslint-disable-line\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransitionDuration = duration;\n    elStyle.transitionDuration = duration;\n  }\n  return this;\n}\n// Events\nfunction on(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  function handleLiveEvent(e) {\n    const target = e.target;\n    if (!target) return;\n    const eventData = e.target.dom7EventData || [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    if ($(target).is(targetSelector)) listener.apply(target, eventData);\n    else {\n      const parents = $(target).parents(); // eslint-disable-line\n      for (let k = 0; k < parents.length; k += 1) {\n        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n      }\n    }\n  }\n  function handleEvent(e) {\n    const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    listener.apply(this, eventData);\n  }\n  const events = eventType.split(' ');\n  let j;\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7Listeners) el.dom7Listeners = {};\n        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener,\n          proxyListener: handleEvent,\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n        el.dom7LiveListeners[event].push({\n          listener,\n          proxyListener: handleLiveEvent,\n        });\n        el.addEventListener(event, handleLiveEvent, capture);\n      }\n    }\n  }\n  return this;\n}\nfunction off(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  const events = eventType.split(' ');\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let handlers;\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n      if (handlers && handlers.length) {\n        for (let k = handlers.length - 1; k >= 0; k -= 1) {\n          const handler = handlers[k];\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction once(...args) {\n  const dom = this;\n  let [eventName, targetSelector, listener, capture] = args;\n  if (typeof args[1] === 'function') {\n    [eventName, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  function onceHandler(...eventArgs) {\n    listener.apply(this, eventArgs);\n    dom.off(eventName, targetSelector, onceHandler, capture);\n    if (onceHandler.dom7proxy) {\n      delete onceHandler.dom7proxy;\n    }\n  }\n  onceHandler.dom7proxy = listener;\n  return dom.on(eventName, targetSelector, onceHandler, capture);\n}\nfunction trigger(...args) {\n  const events = args[0].split(' ');\n  const eventData = args[1];\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let evt;\n      try {\n        evt = new window.CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true,\n        });\n      } catch (e) {\n        evt = document.createEvent('Event');\n        evt.initEvent(event, true, true);\n        evt.detail = eventData;\n      }\n      // eslint-disable-next-line\n      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n      el.dispatchEvent(evt);\n      el.dom7EventData = [];\n      delete el.dom7EventData;\n    }\n  }\n  return this;\n}\nfunction transitionEnd(callback) {\n  const events = ['webkitTransitionEnd', 'transitionend'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    /* jshint validthis:true */\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\nfunction animationEnd(callback) {\n  const events = ['webkitAnimationEnd', 'animationend'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\n// Sizing/Styles\nfunction width() {\n  if (this[0] === window) {\n    return window.innerWidth;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('width'));\n  }\n\n  return null;\n}\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));\n    }\n    return this[0].offsetWidth;\n  }\n  return null;\n}\nfunction height() {\n  if (this[0] === window) {\n    return window.innerHeight;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('height'));\n  }\n\n  return null;\n}\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));\n    }\n    return this[0].offsetHeight;\n  }\n  return null;\n}\nfunction offset() {\n  if (this.length > 0) {\n    const el = this[0];\n    const box = el.getBoundingClientRect();\n    const body = document.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window ? window.scrollY : el.scrollTop;\n    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: (box.top + scrollTop) - clientTop,\n      left: (box.left + scrollLeft) - clientLeft,\n    };\n  }\n\n  return null;\n}\nfunction hide() {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.display = 'none';\n  }\n  return this;\n}\nfunction show() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.style.display === 'none') {\n      el.style.display = '';\n    }\n    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {\n      // Still not visible\n      el.style.display = 'block';\n    }\n  }\n  return this;\n}\nfunction styles() {\n  if (this[0]) return window.getComputedStyle(this[0], null);\n  return {};\n}\nfunction css(props, value) {\n  let i;\n  if (arguments.length === 1) {\n    if (typeof props === 'string') {\n      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      for (i = 0; i < this.length; i += 1) {\n        // eslint-disable-next-line\n        for (let prop in props) {\n          this[i].style[prop] = props[prop];\n        }\n      }\n      return this;\n    }\n  }\n  if (arguments.length === 2 && typeof props === 'string') {\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n    return this;\n  }\n  return this;\n}\n\n// Dom manipulation\nfunction toArray() {\n  const arr = [];\n  for (let i = 0; i < this.length; i += 1) {\n    arr.push(this[i]);\n  }\n  return arr;\n}\n// Iterate over the collection passing elements to `callback`\nfunction each(callback) {\n  // Don't bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], i, this[i]) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction forEach(callback) {\n  // Don't bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], this[i], i) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction filter(callback) {\n  const matchedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);\n  }\n  return new Dom7(matchedItems);\n}\nfunction map(callback) {\n  const modifiedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    modifiedItems.push(callback.call(dom[i], i, dom[i]));\n  }\n  return new Dom7(modifiedItems);\n}\n// eslint-disable-next-line\nfunction html(html) {\n  if (typeof html === 'undefined') {\n    return this[0] ? this[0].innerHTML : undefined;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html;\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction text(text) {\n  if (typeof text === 'undefined') {\n    if (this[0]) {\n      return this[0].textContent.trim();\n    }\n    return null;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].textContent = text;\n  }\n  return this;\n}\nfunction is(selector) {\n  const el = this[0];\n  let compareWith;\n  let i;\n  if (!el || typeof selector === 'undefined') return false;\n  if (typeof selector === 'string') {\n    if (el.matches) return el.matches(selector);\n    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n\n    compareWith = $(selector);\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  } else if (selector === document) return el === document;\n  else if (selector === window) return el === window;\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  }\n  return false;\n}\nfunction indexOf(el) {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i] === el) return i;\n  }\n  return -1;\n}\nfunction index() {\n  let child = this[0];\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\n// eslint-disable-next-line\nfunction eq(index) {\n  if (typeof index === 'undefined') return this;\n  const length = this.length;\n  let returnIndex;\n  if (index > length - 1) {\n    return new Dom7([]);\n  }\n  if (index < 0) {\n    returnIndex = length + index;\n    if (returnIndex < 0) return new Dom7([]);\n    return new Dom7([this[returnIndex]]);\n  }\n  return new Dom7([this[index]]);\n}\nfunction append(...args) {\n  let newChild;\n\n  for (let k = 0; k < args.length; k += 1) {\n    newChild = args[k];\n    for (let i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = newChild;\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (let j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n// eslint-disable-next-line\nfunction appendTo(parent) {\n  $(parent).append(this);\n  return this;\n}\nfunction prepend(newChild) {\n  let i;\n  let j;\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === 'string') {\n      const tempDiv = document.createElement('div');\n      tempDiv.innerHTML = newChild;\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prependTo(parent) {\n  $(parent).prepend(this);\n  return this;\n}\nfunction insertBefore(selector) {\n  const before = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (before.length === 1) {\n      before[0].parentNode.insertBefore(this[i], before[0]);\n    } else if (before.length > 1) {\n      for (let j = 0; j < before.length; j += 1) {\n        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n      }\n    }\n  }\n}\nfunction insertAfter(selector) {\n  const after = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (after.length === 1) {\n      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n    } else if (after.length > 1) {\n      for (let j = 0; j < after.length; j += 1) {\n        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n      }\n    }\n  }\n}\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return new Dom7([this[0].nextElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction nextAll(selector) {\n  const nextEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(next).is(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return new Dom7(nextEls);\n}\nfunction prev(selector) {\n  if (this.length > 0) {\n    const el = this[0];\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return new Dom7([el.previousElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction prevAll(selector) {\n  const prevEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(prev).is(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return new Dom7(prevEls);\n}\nfunction siblings(selector) {\n  return this.nextAll(selector).add(this.prevAll(selector));\n}\nfunction parent(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n      } else {\n        parents.push(this[i].parentNode);\n      }\n    }\n  }\n  return $(unique(parents));\n}\nfunction parents(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    let parent = this[i].parentNode; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if ($(parent).is(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n  }\n  return $(unique(parents));\n}\nfunction closest(selector) {\n  let closest = this; // eslint-disable-line\n  if (typeof selector === 'undefined') {\n    return new Dom7([]);\n  }\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n  return closest;\n}\nfunction find(selector) {\n  const foundElements = [];\n  for (let i = 0; i < this.length; i += 1) {\n    const found = this[i].querySelectorAll(selector);\n    for (let j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n  return new Dom7(foundElements);\n}\nfunction children(selector) {\n  const children = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    const childNodes = this[i].childNodes;\n\n    for (let j = 0; j < childNodes.length; j += 1) {\n      if (!selector) {\n        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);\n      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n  return new Dom7(unique(children));\n}\nfunction remove() {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n  }\n  return this;\n}\nfunction detach() {\n  return this.remove();\n}\nfunction add(...args) {\n  const dom = this;\n  let i;\n  let j;\n  for (i = 0; i < args.length; i += 1) {\n    const toAdd = $(args[i]);\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom[dom.length] = toAdd[j];\n      dom.length += 1;\n    }\n  }\n  return dom;\n}\nfunction empty() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.nodeType === 1) {\n      for (let j = 0; j < el.childNodes.length; j += 1) {\n        if (el.childNodes[j].parentNode) {\n          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);\n        }\n      }\n      el.textContent = '';\n    }\n  }\n  return this;\n}\n\nfunction scrollTo(...args) {\n  let [left, top, duration, easing, callback] = args;\n  if (args.length === 4 && typeof easing === 'function') {\n    callback = easing;\n    [left, top, duration, callback, easing] = args;\n  }\n  if (typeof easing === 'undefined') easing = 'swing';\n\n  return this.each(function animate() {\n    const el = this;\n    let currentTop;\n    let currentLeft;\n    let maxTop;\n    let maxLeft;\n    let newTop;\n    let newLeft;\n    let scrollTop; // eslint-disable-line\n    let scrollLeft; // eslint-disable-line\n    let animateTop = top > 0 || top === 0;\n    let animateLeft = left > 0 || left === 0;\n    if (typeof easing === 'undefined') {\n      easing = 'swing';\n    }\n    if (animateTop) {\n      currentTop = el.scrollTop;\n      if (!duration) {\n        el.scrollTop = top;\n      }\n    }\n    if (animateLeft) {\n      currentLeft = el.scrollLeft;\n      if (!duration) {\n        el.scrollLeft = left;\n      }\n    }\n    if (!duration) return;\n    if (animateTop) {\n      maxTop = el.scrollHeight - el.offsetHeight;\n      newTop = Math.max(Math.min(top, maxTop), 0);\n    }\n    if (animateLeft) {\n      maxLeft = el.scrollWidth - el.offsetWidth;\n      newLeft = Math.max(Math.min(left, maxLeft), 0);\n    }\n    let startTime = null;\n    if (animateTop && newTop === currentTop) animateTop = false;\n    if (animateLeft && newLeft === currentLeft) animateLeft = false;\n    function render(time = new Date().getTime()) {\n      if (startTime === null) {\n        startTime = time;\n      }\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));\n      let done;\n      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));\n      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));\n      if (animateTop && newTop > currentTop && scrollTop >= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateTop && newTop < currentTop && scrollTop <= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (done) {\n        if (callback) callback();\n        return;\n      }\n      if (animateTop) el.scrollTop = scrollTop;\n      if (animateLeft) el.scrollLeft = scrollLeft;\n      requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n  });\n}\n// scrollTop(top, duration, easing, callback) {\nfunction scrollTop(...args) {\n  let [top, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === 'function') {\n    [top, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof top === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollTop;\n    return null;\n  }\n  return dom.scrollTo(undefined, top, duration, easing, callback);\n}\nfunction scrollLeft(...args) {\n  let [left, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === 'function') {\n    [left, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof left === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollLeft;\n    return null;\n  }\n  return dom.scrollTo(left, undefined, duration, easing, callback);\n}\n\nfunction animate(initialProps, initialParams) {\n  const els = this;\n  const a = {\n    props: Object.assign({}, initialProps),\n    params: Object.assign({\n      duration: 300,\n      easing: 'swing', // or 'linear'\n      /* Callbacks\n      begin(elements)\n      complete(elements)\n      progress(elements, complete, remaining, start, tweenValue)\n      */\n    }, initialParams),\n\n    elements: els,\n    animating: false,\n    que: [],\n\n    easingProgress(easing, progress) {\n      if (easing === 'swing') {\n        return 0.5 - (Math.cos(progress * Math.PI) / 2);\n      }\n      if (typeof easing === 'function') {\n        return easing(progress);\n      }\n      return progress;\n    },\n    stop() {\n      if (a.frameId) {\n        cancelAnimationFrame(a.frameId);\n      }\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      a.que = [];\n    },\n    done(complete) {\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      if (complete) complete(els);\n      if (a.que.length > 0) {\n        const que = a.que.shift();\n        a.animate(que[0], que[1]);\n      }\n    },\n    animate(props, params) {\n      if (a.animating) {\n        a.que.push([props, params]);\n        return a;\n      }\n      const elements = [];\n\n      // Define & Cache Initials & Units\n      a.elements.each((index, el) => {\n        let initialFullValue;\n        let initialValue;\n        let unit;\n        let finalValue;\n        let finalFullValue;\n\n        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;\n\n        elements[index] = {\n          container: el,\n        };\n        Object.keys(props).forEach((prop) => {\n          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');\n          initialValue = parseFloat(initialFullValue);\n          unit = initialFullValue.replace(initialValue, '');\n          finalValue = parseFloat(props[prop]);\n          finalFullValue = props[prop] + unit;\n          elements[index][prop] = {\n            initialFullValue,\n            initialValue,\n            unit,\n            finalValue,\n            finalFullValue,\n            currentValue: initialValue,\n          };\n        });\n      });\n\n      let startTime = null;\n      let time;\n      let elementsDone = 0;\n      let propsDone = 0;\n      let done;\n      let began = false;\n\n      a.animating = true;\n\n      function render() {\n        time = new Date().getTime();\n        let progress;\n        let easeProgress;\n        // let el;\n        if (!began) {\n          began = true;\n          if (params.begin) params.begin(els);\n        }\n        if (startTime === null) {\n          startTime = time;\n        }\n        if (params.progress) {\n          // eslint-disable-next-line\n          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);\n        }\n\n        elements.forEach((element) => {\n          const el = element;\n          if (done || el.done) return;\n          Object.keys(props).forEach((prop) => {\n            if (done || el.done) return;\n            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);\n            easeProgress = a.easingProgress(params.easing, progress);\n            const { initialValue, finalValue, unit } = el[prop];\n            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));\n            const currentValue = el[prop].currentValue;\n\n            if (\n              (finalValue > initialValue && currentValue >= finalValue) ||\n              (finalValue < initialValue && currentValue <= finalValue)) {\n              el.container.style[prop] = finalValue + unit;\n              propsDone += 1;\n              if (propsDone === Object.keys(props).length) {\n                el.done = true;\n                elementsDone += 1;\n              }\n              if (elementsDone === elements.length) {\n                done = true;\n              }\n            }\n            if (done) {\n              a.done(params.complete);\n              return;\n            }\n            el.container.style[prop] = currentValue + unit;\n          });\n        });\n        if (done) return;\n        // Then call\n        a.frameId = requestAnimationFrame(render);\n      }\n      a.frameId = requestAnimationFrame(render);\n      return a;\n    },\n  };\n\n  if (a.elements.length === 0) {\n    return els;\n  }\n\n  let animateInstance;\n  for (let i = 0; i < a.elements.length; i += 1) {\n    if (a.elements[i].dom7AnimateInstance) {\n      animateInstance = a.elements[i].dom7AnimateInstance;\n    } else a.elements[i].dom7AnimateInstance = a;\n  }\n  if (!animateInstance) {\n    animateInstance = a;\n  }\n\n  if (initialProps === 'stop') {\n    animateInstance.stop();\n  } else {\n    animateInstance.animate(a.props, a.params);\n  }\n\n  return els;\n}\n\nfunction stop() {\n  const els = this;\n  for (let i = 0; i < els.length; i += 1) {\n    if (els[i].dom7AnimateInstance) {\n      els[i].dom7AnimateInstance.stop();\n    }\n  }\n}\n\nconst noTrigger = ('resize scroll').split(' ');\nfunction eventShortcut(name, ...args) {\n  if (typeof args[0] === 'undefined') {\n    for (let i = 0; i < this.length; i += 1) {\n      if (noTrigger.indexOf(name) < 0) {\n        if (name in this[i]) this[i][name]();\n        else {\n          $(this[i]).trigger(name);\n        }\n      }\n    }\n    return this;\n  }\n  return this.on(name, ...args);\n}\n\nfunction click(...args) {\n  return eventShortcut.bind(this)('click', ...args);\n}\nfunction blur(...args) {\n  return eventShortcut.bind(this)('blur', ...args);\n}\nfunction focus(...args) {\n  return eventShortcut.bind(this)('focus', ...args);\n}\nfunction focusin(...args) {\n  return eventShortcut.bind(this)('focusin', ...args);\n}\nfunction focusout(...args) {\n  return eventShortcut.bind(this)('focusout', ...args);\n}\nfunction keyup(...args) {\n  return eventShortcut.bind(this)('keyup', ...args);\n}\nfunction keydown(...args) {\n  return eventShortcut.bind(this)('keydown', ...args);\n}\nfunction keypress(...args) {\n  return eventShortcut.bind(this)('keypress', ...args);\n}\nfunction submit(...args) {\n  return eventShortcut.bind(this)('submit', ...args);\n}\nfunction change(...args) {\n  return eventShortcut.bind(this)('change', ...args);\n}\nfunction mousedown(...args) {\n  return eventShortcut.bind(this)('mousedown', ...args);\n}\nfunction mousemove(...args) {\n  return eventShortcut.bind(this)('mousemove', ...args);\n}\nfunction mouseup(...args) {\n  return eventShortcut.bind(this)('mouseup', ...args);\n}\nfunction mouseenter(...args) {\n  return eventShortcut.bind(this)('mouseenter', ...args);\n}\nfunction mouseleave(...args) {\n  return eventShortcut.bind(this)('mouseleave', ...args);\n}\nfunction mouseout(...args) {\n  return eventShortcut.bind(this)('mouseout', ...args);\n}\nfunction mouseover(...args) {\n  return eventShortcut.bind(this)('mouseover', ...args);\n}\nfunction touchstart(...args) {\n  return eventShortcut.bind(this)('touchstart', ...args);\n}\nfunction touchend(...args) {\n  return eventShortcut.bind(this)('touchend', ...args);\n}\nfunction touchmove(...args) {\n  return eventShortcut.bind(this)('touchmove', ...args);\n}\nfunction resize(...args) {\n  return eventShortcut.bind(this)('resize', ...args);\n}\nfunction scroll(...args) {\n  return eventShortcut.bind(this)('scroll', ...args);\n}\n\nexport { $, addClass, removeClass, hasClass, toggleClass, attr, removeAttr, prop, data, removeData, dataset, val, transform, transition, on, off, once, trigger, transitionEnd, animationEnd, width, outerWidth, height, outerHeight, offset, hide, show, styles, css, toArray, each, forEach, filter, map, html, text, is, indexOf, index, eq, append, appendTo, prepend, prependTo, insertBefore, insertAfter, next, nextAll, prev, prevAll, siblings, parent, parents, closest, find, children, remove, detach, add, empty, scrollTo, scrollTop, scrollLeft, animate, stop, click, blur, focus, focusin, focusout, keyup, keydown, keypress, submit, change, mousedown, mousemove, mouseup, mouseenter, mouseleave, mouseout, mouseover, touchstart, touchend, touchmove, resize, scroll };\n","/**\n * Swiper 4.5.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * http://www.idangero.us/swiper/\n *\n * Copyright 2014-2019 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: February 22, 2019\n */\n\nimport { $, addClass, removeClass, hasClass, toggleClass, attr, removeAttr, data, transform, transition as transition$1, on, off, trigger, transitionEnd as transitionEnd$1, outerWidth, outerHeight, offset, css, each, html, text, is, index, eq, append, prepend, next, nextAll, prev, prevAll, parent, parents, closest, find, children, remove, add, styles } from 'dom7/dist/dom7.modular';\nimport { window, document } from 'ssr-window';\n\nconst Methods = {\n  addClass,\n  removeClass,\n  hasClass,\n  toggleClass,\n  attr,\n  removeAttr,\n  data,\n  transform,\n  transition: transition$1,\n  on,\n  off,\n  trigger,\n  transitionEnd: transitionEnd$1,\n  outerWidth,\n  outerHeight,\n  offset,\n  css,\n  each,\n  html,\n  text,\n  is,\n  index,\n  eq,\n  append,\n  prepend,\n  next,\n  nextAll,\n  prev,\n  prevAll,\n  parent,\n  parents,\n  closest,\n  find,\n  children,\n  remove,\n  add,\n  styles,\n};\n\nObject.keys(Methods).forEach((methodName) => {\n  $.fn[methodName] = Methods[methodName];\n});\n\nconst Utils = {\n  deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key) => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  },\n  nextTick(callback, delay = 0) {\n    return setTimeout(callback, delay);\n  },\n  now() {\n    return Date.now();\n  },\n  getTranslate(el, axis = 'x') {\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n\n    const curStyle = window.getComputedStyle(el, null);\n\n    if (window.WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n  },\n  parseUrlQuery(url) {\n    const query = {};\n    let urlToParse = url || window.location.href;\n    let i;\n    let params;\n    let param;\n    let length;\n    if (typeof urlToParse === 'string' && urlToParse.length) {\n      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\\S*\\?/, '') : '';\n      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');\n      length = params.length;\n\n      for (i = 0; i < length; i += 1) {\n        param = params[i].replace(/#\\S+/g, '').split('=');\n        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';\n      }\n    }\n    return query;\n  },\n  isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;\n  },\n  extend(...args) {\n    const to = Object(args[0]);\n    for (let i = 1; i < args.length; i += 1) {\n      const nextSource = args[i];\n      if (nextSource !== undefined && nextSource !== null) {\n        const keysArray = Object.keys(Object(nextSource));\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  },\n};\n\nconst Support = (function Support() {\n  const testDiv = document.createElement('div');\n  return {\n    touch: (window.Modernizr && window.Modernizr.touch === true) || (function checkTouch() {\n      return !!((window.navigator.maxTouchPoints > 0) || ('ontouchstart' in window) || (window.DocumentTouch && document instanceof window.DocumentTouch));\n    }()),\n\n    pointerEvents: !!(window.navigator.pointerEnabled || window.PointerEvent || ('maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints > 0)),\n    prefixedPointerEvents: !!window.navigator.msPointerEnabled,\n\n    transition: (function checkTransition() {\n      const style = testDiv.style;\n      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);\n    }()),\n    transforms3d: (window.Modernizr && window.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {\n      const style = testDiv.style;\n      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);\n    }()),\n\n    flexbox: (function checkFlexbox() {\n      const style = testDiv.style;\n      const styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');\n      for (let i = 0; i < styles.length; i += 1) {\n        if (styles[i] in style) return true;\n      }\n      return false;\n    }()),\n\n    observer: (function checkObserver() {\n      return ('MutationObserver' in window || 'WebkitMutationObserver' in window);\n    }()),\n\n    passiveListener: (function checkPassiveListener() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          // eslint-disable-next-line\n          get() {\n            supportsPassive = true;\n          },\n        });\n        window.addEventListener('testPassiveListener', null, opts);\n      } catch (e) {\n        // No support\n      }\n      return supportsPassive;\n    }()),\n\n    gestures: (function checkGestures() {\n      return 'ongesturestart' in window;\n    }()),\n  };\n}());\n\nconst Browser = (function Browser() {\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);\n  }\n  return {\n    isIE: !!window.navigator.userAgent.match(/Trident/g) || !!window.navigator.userAgent.match(/MSIE/g),\n    isEdge: !!window.navigator.userAgent.match(/Edge/g),\n    isSafari: isSafari(),\n    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n  };\n}());\n\nclass SwiperClass {\n  constructor(params = {}) {\n    const self = this;\n    self.params = params;\n\n    // Events\n    self.eventsListeners = {};\n\n    if (self.params && self.params.on) {\n      Object.keys(self.params.on).forEach((eventName) => {\n        self.on(eventName, self.params.on[eventName]);\n      });\n    }\n  }\n\n  on(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  }\n\n  once(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      handler.apply(self, args);\n      self.off(events, onceHandler);\n      if (onceHandler.f7proxy) {\n        delete onceHandler.f7proxy;\n      }\n    }\n    onceHandler.f7proxy = handler;\n    return self.on(events, onceHandler, priority);\n  }\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  }\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach((event) => {\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        const handlers = [];\n        self.eventsListeners[event].forEach((eventHandler) => {\n          handlers.push(eventHandler);\n        });\n        handlers.forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n\n  useModulesParams(instanceParams) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      // Extend params\n      if (module.params) {\n        Utils.extend(instanceParams, module.params);\n      }\n    });\n  }\n\n  useModules(modulesParams = {}) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      const moduleParams = modulesParams[moduleName] || {};\n      // Extend instance methods and props\n      if (module.instance) {\n        Object.keys(module.instance).forEach((modulePropName) => {\n          const moduleProp = module.instance[modulePropName];\n          if (typeof moduleProp === 'function') {\n            instance[modulePropName] = moduleProp.bind(instance);\n          } else {\n            instance[modulePropName] = moduleProp;\n          }\n        });\n      }\n      // Add event listeners\n      if (module.on && instance.on) {\n        Object.keys(module.on).forEach((moduleEventName) => {\n          instance.on(moduleEventName, module.on[moduleEventName]);\n        });\n      }\n\n      // Module create callback\n      if (module.create) {\n        module.create.bind(instance)(moduleParams);\n      }\n    });\n  }\n\n  static set components(components) {\n    const Class = this;\n    if (!Class.use) return;\n    Class.use(components);\n  }\n\n  static installModule(module, ...params) {\n    const Class = this;\n    if (!Class.prototype.modules) Class.prototype.modules = {};\n    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);\n    Class.prototype.modules[name] = module;\n    // Prototype\n    if (module.proto) {\n      Object.keys(module.proto).forEach((key) => {\n        Class.prototype[key] = module.proto[key];\n      });\n    }\n    // Class\n    if (module.static) {\n      Object.keys(module.static).forEach((key) => {\n        Class[key] = module.static[key];\n      });\n    }\n    // Callback\n    if (module.install) {\n      module.install.apply(Class, params);\n    }\n    return Class;\n  }\n\n  static use(module, ...params) {\n    const Class = this;\n    if (Array.isArray(module)) {\n      module.forEach(m => Class.installModule(m));\n      return Class;\n    }\n    return Class.installModule(module, ...params);\n  }\n}\n\nfunction updateSize () {\n  const swiper = this;\n  let width;\n  let height;\n  const $el = swiper.$el;\n  if (typeof swiper.params.width !== 'undefined') {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined') {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);\n  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);\n\n  Utils.extend(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n\nfunction updateSlides () {\n  const swiper = this;\n  const params = swiper.params;\n\n  const {\n    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.snapGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  if (rtl) slides.css({ marginLeft: '', marginTop: '' });\n  else slides.css({ marginRight: '', marginBottom: '' });\n\n  let slidesNumberEvenToRows;\n  if (params.slidesPerColumn > 1) {\n    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\n    }\n    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\n    }\n  }\n\n  // Calc slides\n  let slideSize;\n  const slidesPerColumn = params.slidesPerColumn;\n  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\n  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n    if (params.slidesPerColumn > 1) {\n      // Set slides order\n      let newSlideOrderIndex;\n      let column;\n      let row;\n      if (params.slidesPerColumnFill === 'column') {\n        column = Math.floor(i / slidesPerColumn);\n        row = i - (column * slidesPerColumn);\n        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {\n          row += 1;\n          if (row >= slidesPerColumn) {\n            row = 0;\n            column += 1;\n          }\n        }\n        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);\n        slide\n          .css({\n            '-webkit-box-ordinal-group': newSlideOrderIndex,\n            '-moz-box-ordinal-group': newSlideOrderIndex,\n            '-ms-flex-order': newSlideOrderIndex,\n            '-webkit-order': newSlideOrderIndex,\n            order: newSlideOrderIndex,\n          });\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - (row * slidesPerRow);\n      }\n      slide\n        .css(\n          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,\n          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)\n        )\n        .attr('data-swiper-column', column)\n        .attr('data-swiper-row', row);\n    }\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      const slideStyles = window.getComputedStyle(slide[0], null);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal()\n          ? slide.outerWidth(true)\n          : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        if (swiper.isHorizontal()) {\n          const width = parseFloat(slideStyles.getPropertyValue('width'));\n          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));\n          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));\n          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));\n          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;\n          }\n        } else {\n          const height = parseFloat(slideStyles.getPropertyValue('height'));\n          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));\n          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));\n          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));\n          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = height + marginTop + marginBottom;\n          } else {\n            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;\n          }\n        }\n      }\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        if (swiper.isHorizontal()) {\n          slides[i].style.width = `${slideSize}px`;\n        } else {\n          slides[i].style.height = `${slideSize}px`;\n        }\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  let newSlidesGrid;\n\n  if (\n    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n  if (!Support.flexbox || params.setWrapperSize) {\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n\n  if (params.slidesPerColumn > 1) {\n    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n    if (params.centeredSlides) {\n      newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid = newSlidesGrid;\n    }\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    if (swiper.isHorizontal()) {\n      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });\n      else slides.css({ marginRight: `${spaceBetween}px` });\n    } else slides.css({ marginBottom: `${spaceBetween}px` });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Utils.extend(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateSlidesOffset();\n  }\n}\n\nfunction updateAutoHeight (speed) {\n  const swiper = this;\n  const activeSlides = [];\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n      const index = swiper.activeIndex + i;\n      if (index > swiper.slides.length) break;\n      activeSlides.push(swiper.slides.eq(index)[0]);\n    }\n  } else {\n    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);\n}\n\nfunction updateSlidesOffset () {\n  const swiper = this;\n  const slides = swiper.slides;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n}\n\nfunction updateSlidesProgress (translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.removeClass(params.slideVisibleClass);\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    const slideProgress = (\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset\n    ) / (slide.swiperSlideSize + params.spaceBetween);\n    if (params.watchSlidesVisibility) {\n      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size)\n                || (slideAfter > 0 && slideAfter <= swiper.size)\n                || (slideBefore <= 0 && slideAfter >= swiper.size);\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n  }\n  swiper.visibleSlides = $(swiper.visibleSlides);\n}\n\nfunction updateProgress (translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / (translatesDiff);\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Utils.extend(swiper, {\n    progress,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n\nfunction updateSlidesClasses () {\n  const swiper = this;\n\n  const {\n    slides, params, $wrapperEl, activeIndex, realIndex,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);\n\n  let activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n\n  // Active classes\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  // Next Slide\n  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  // Prev Slide\n  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    }\n  }\n}\n\nfunction updateActiveIndex (newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  if (typeof activeIndex === 'undefined') {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n\n  // Get real index\n  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n\n  Utils.extend(swiper, {\n    snapIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  swiper.emit('slideChange');\n}\n\nfunction updateClickedSlide (e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = $(e.target).closest(`.${params.slideClass}`)[0];\n  let slideFound = false;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) slideFound = true;\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = $(slide).index();\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n\nfunction getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const {\n    params, rtlTranslate: rtl, translate, $wrapperEl,\n  } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n\n  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n\nfunction setTranslate (translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl, params, $wrapperEl, progress,\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (!params.virtualTranslate) {\n    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate () {\n  return (-this.snapGrid[0]);\n}\n\nfunction maxTranslate () {\n  return (-this.snapGrid[this.snapGrid.length - 1]);\n}\n\nvar translate = {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n};\n\nfunction setTransition (duration, byController) {\n  const swiper = this;\n\n  swiper.$wrapperEl.transition(duration);\n\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionStart (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, params, previousIndex } = swiper;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionStart');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionStart');\n      return;\n    }\n    swiper.emit('slideChangeTransitionStart');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionStart');\n    } else {\n      swiper.emit('slidePrevTransitionStart');\n    }\n  }\n}\n\nfunction transitionEnd (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, previousIndex } = swiper;\n  swiper.animating = false;\n  swiper.setTransition(0);\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionEnd');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionEnd');\n      return;\n    }\n    swiper.emit('slideChangeTransitionEnd');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionEnd');\n    } else {\n      swiper.emit('slidePrevTransitionEnd');\n    }\n  }\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n\nfunction slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  const translate = -snapGrid[snapIndex];\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n\n  if (speed === 0 || !Support.transition) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\nfunction slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, animating } = swiper;\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params, animating, snapGrid, slidesGrid, rtlTranslate,\n  } = swiper;\n\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n  const normalizedSlidesGrid = slidesGrid.map(val => normalize(val));\n\n  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];\n  const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  let prevIndex;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);\n\n  if (snapIndex < swiper.snapGrid.length - 1) {\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n\n    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {\n      index = swiper.params.slidesPerGroup;\n    }\n  }\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))\n        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))\n      ) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n          .eq(0)\n          .index();\n\n        Utils.nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl\n        .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n        .eq(0)\n        .index();\n\n      Utils.nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n\nfunction loopCreate () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n  // Remove duplicated slides\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n\n  let slides = $wrapperEl.children(`.${params.slideClass}`);\n\n  if (params.loopFillGroupWithBlank) {\n    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (let i = 0; i < blankSlidesNum; i += 1) {\n        const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n        $wrapperEl.append(blankNode);\n      }\n      slides = $wrapperEl.children(`.${params.slideClass}`);\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n\n  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  const prependSlides = [];\n  const appendSlides = [];\n  slides.each((index, el) => {\n    const slide = $(el);\n    if (index < swiper.loopedSlides) appendSlides.push(el);\n    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);\n    slide.attr('data-swiper-slide-index', index);\n  });\n  for (let i = 0; i < appendSlides.length; i += 1) {\n    $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n    $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\n\nfunction loopFix () {\n  const swiper = this;\n  const {\n    params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,\n  } = swiper;\n  let newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  const snapTranslate = -snapGrid[activeIndex];\n  const diff = snapTranslate - swiper.getTranslate();\n\n\n  // Fix For Negative Oversliding\n  if (activeIndex < loopedSlides) {\n    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n}\n\nfunction loopDestroy () {\n  const swiper = this;\n  const { $wrapperEl, params, slides } = swiper;\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();\n  slides.removeAttr('data-swiper-slide-index');\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n\nfunction setGrabCursor (moving) {\n  const swiper = this;\n  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;\n  const el = swiper.el;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n}\n\nfunction unsetGrabCursor () {\n  const swiper = this;\n  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;\n  swiper.el.style.cursor = '';\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n\nfunction appendSlide (slides) {\n  const swiper = this;\n  const { $wrapperEl, params } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n}\n\nfunction prependSlide (slides) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.prepend(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\nfunction addSlide (index, slides) {\n  const swiper = this;\n  const { $wrapperEl, params, activeIndex } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides.eq(i);\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    $wrapperEl.append(slidesBuffer[i]);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeSlide (slidesIndexes) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeAllSlides () {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n\nvar manipulation = {\n  appendSlide,\n  prependSlide,\n  addSlide,\n  removeSlide,\n  removeAllSlides,\n};\n\nconst Device = (function Device() {\n  const ua = window.navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n    androidChrome: false,\n    desktop: false,\n    windows: false,\n    iphone: false,\n    ipod: false,\n    ipad: false,\n    cordova: window.cordova || window.phonegap,\n    phonegap: window.cordova || window.phonegap,\n  };\n\n  const windows = ua.match(/(Windows Phone);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  const ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n\n\n  // Windows\n  if (windows) {\n    device.os = 'windows';\n    device.osVersion = windows[2];\n    device.windows = true;\n  }\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.osVersion = android[2];\n    device.android = true;\n    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n  // iOS\n  if (iphone && !ipod) {\n    device.osVersion = iphone[2].replace(/_/g, '.');\n    device.iphone = true;\n  }\n  if (ipad) {\n    device.osVersion = ipad[2].replace(/_/g, '.');\n    device.ipad = true;\n  }\n  if (ipod) {\n    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    device.iphone = true;\n  }\n  // iOS 8+ changed UA\n  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {\n    if (device.osVersion.split('.')[0] === '10') {\n      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];\n    }\n  }\n\n  // Desktop\n  device.desktop = !(device.os || device.android || device.webView);\n\n  // Webview\n  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);\n\n  // Minimal UI\n  if (device.os && device.os === 'ios') {\n    const osVersionArr = device.osVersion.split('.');\n    const metaViewport = document.querySelector('meta[name=\"viewport\"]');\n    device.minimalUi = !device.webView\n      && (ipod || iphone)\n      && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)\n      && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;\n  }\n\n  // Pixel Ratio\n  device.pixelRatio = window.devicePixelRatio || 1;\n\n  // Export object\n  return device;\n}());\n\nfunction onTouchStart (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n  if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!$(e).closest(params.swipeHandler)[0]) return;\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection\n    && ((startX <= edgeSwipeThreshold)\n    || (startX >= window.screen.width - edgeSwipeThreshold))\n  ) {\n    return;\n  }\n\n  Utils.extend(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = Utils.now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  if (e.type !== 'touchstart') {\n    let preventDefault = true;\n    if ($(e.target).is(data.formElements)) preventDefault = false;\n    if (\n      document.activeElement\n      && $(document.activeElement).is(data.formElements)\n      && document.activeElement !== e.target\n    ) {\n      document.activeElement.blur();\n    }\n\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if (params.touchStartForcePreventDefault || shouldPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  if (data.isTouchEvent && e.type === 'mousemove') return;\n  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    // isMoved = true;\n    swiper.allowClick = false;\n    if (data.isTouched) {\n      Utils.extend(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = Utils.now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())\n        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())\n      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && document.activeElement) {\n    if (e.target === document.activeElement && $(e.target).is(data.formElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if ((diffX * diffX) + (diffY * diffY) >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  e.preventDefault();\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) diff = -diff;\n\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger) return;\n\n  // Update active index in free mode\n  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode) {\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: Utils.now(),\n    });\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const {\n    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      data.clickTimeout = Utils.nextTick(() => {\n        if (!swiper || swiper.destroyed) return;\n        swiper.emit('click', e);\n      }, 300);\n    }\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      swiper.emit('doubleTap', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\n    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      swiper.slideTo(stopIndex + params.slidesPerGroup);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize () {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  if (params.freeMode) {\n    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());\n    swiper.setTranslate(newTranslate);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n  } else {\n    swiper.updateSlidesClasses();\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick (e) {\n  const swiper = this;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  {\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n\n  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  const capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);\n      document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);\n        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.addEventListener('mousedown', swiper.onTouchStart, false);\n        document.addEventListener('mousemove', swiper.onTouchMove, capture);\n        document.addEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.addEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);\n}\n\nfunction detachEvents() {\n  const swiper = this;\n\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  const capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\n      document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.removeEventListener('mousedown', swiper.onTouchStart, false);\n        document.removeEventListener('mousemove', swiper.onTouchMove, capture);\n        document.removeEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.removeEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);\n}\n\nvar events = {\n  attachEvents,\n  detachEvents,\n};\n\nfunction setBreakpoint () {\n  const swiper = this;\n  const {\n    activeIndex, initialized, loopedSlides = 0, params,\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Set breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints);\n\n  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    if (breakpointOnlyParams) {\n      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach((param) => {\n        const paramValue = breakpointOnlyParams[param];\n        if (typeof paramValue === 'undefined') return;\n        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {\n          breakpointOnlyParams[param] = 'auto';\n        } else if (param === 'slidesPerView') {\n          breakpointOnlyParams[param] = parseFloat(paramValue);\n        } else {\n          breakpointOnlyParams[param] = parseInt(paramValue, 10);\n        }\n      });\n    }\n\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n\n    Utils.extend(swiper.params, breakpointParams);\n\n    Utils.extend(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n    });\n\n    swiper.currentBreakpoint = breakpoint;\n\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate();\n      swiper.updateSlides();\n      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);\n    }\n\n    swiper.emit('breakpoint', breakpointParams);\n  }\n}\n\nfunction getBreakpoint (breakpoints) {\n  const swiper = this;\n  // Get breakpoint for window width\n  if (!breakpoints) return undefined;\n  let breakpoint = false;\n  const points = [];\n  Object.keys(breakpoints).forEach((point) => {\n    points.push(point);\n  });\n  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const point = points[i];\n    if (swiper.params.breakpointsInverse) {\n      if (point <= window.innerWidth) {\n        breakpoint = point;\n      }\n    } else if (point >= window.innerWidth && !breakpoint) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = { setBreakpoint, getBreakpoint };\n\nfunction addClasses () {\n  const swiper = this;\n  const {\n    classNames, params, rtl, $el,\n  } = swiper;\n  const suffixes = [];\n\n  suffixes.push('initialized');\n  suffixes.push(params.direction);\n\n  if (params.freeMode) {\n    suffixes.push('free-mode');\n  }\n  if (!Support.flexbox) {\n    suffixes.push('no-flexbox');\n  }\n  if (params.autoHeight) {\n    suffixes.push('autoheight');\n  }\n  if (rtl) {\n    suffixes.push('rtl');\n  }\n  if (params.slidesPerColumn > 1) {\n    suffixes.push('multirow');\n  }\n  if (Device.android) {\n    suffixes.push('android');\n  }\n  if (Device.ios) {\n    suffixes.push('ios');\n  }\n  // WP8 Touch Events Fix\n  if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n    suffixes.push(`wp8-${params.direction}`);\n  }\n\n  suffixes.forEach((suffix) => {\n    classNames.push(params.containerModifierClass + suffix);\n  });\n\n  $el.addClass(classNames.join(' '));\n}\n\nfunction removeClasses () {\n  const swiper = this;\n  const { $el, classNames } = swiper;\n\n  $el.removeClass(classNames.join(' '));\n}\n\nvar classes = { addClasses, removeClasses };\n\nfunction loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {\n  let image;\n  function onReady() {\n    if (callback) callback();\n  }\n  if (!imageEl.complete || !checkForComplete) {\n    if (src) {\n      image = new window.Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n}\n\nfunction preloadImages () {\n  const swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) swiper.update();\n      swiper.emit('imagesReady');\n    }\n  }\n  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    const imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(\n      imageEl,\n      imageEl.currentSrc || imageEl.getAttribute('src'),\n      imageEl.srcset || imageEl.getAttribute('srcset'),\n      imageEl.sizes || imageEl.getAttribute('sizes'),\n      true,\n      onReady\n    );\n  }\n}\n\nvar images = {\n  loadImage,\n  preloadImages,\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const wasLocked = swiper.isLocked;\n\n  swiper.isLocked = swiper.snapGrid.length === 1;\n  swiper.allowSlideNext = !swiper.isLocked;\n  swiper.allowSlidePrev = !swiper.isLocked;\n\n  // events\n  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n    swiper.navigation.update();\n  }\n}\n\nvar checkOverflow$1 = { checkOverflow };\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'container',\n  initialSlide: 0,\n  speed: 300,\n  //\n  preventInteractionOnTransition: false,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Free mode\n  freeMode: false,\n  freeModeMomentum: true,\n  freeModeMomentumRatio: 1,\n  freeModeMomentumBounce: true,\n  freeModeMomentumBounceRatio: 1,\n  freeModeMomentumVelocityRatio: 1,\n  freeModeSticky: false,\n  freeModeMinimumVelocity: 0.02,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsInverse: false,\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerColumn: 1,\n  slidesPerColumnFill: 'column',\n  slidesPerGroup: 1,\n  centeredSlides: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: false,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: true,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n  watchSlidesVisibility: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopFillGroupWithBlank: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  // NS\n  containerModifierClass: 'swiper-container-', // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n\n  // Callbacks\n  runCallbacksOnInit: true,\n};\n\n/* eslint no-param-reassign: \"off\" */\n\nconst prototypes = {\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  manipulation,\n  events,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes,\n  images,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper extends SwiperClass {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = Utils.extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    super(params);\n\n    Object.keys(prototypes).forEach((prototypeGroup) => {\n      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n        if (!Swiper.prototype[protoMethod]) {\n          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        }\n      });\n    });\n\n    // Swiper Instance\n    const swiper = this;\n    if (typeof swiper.modules === 'undefined') {\n      swiper.modules = {};\n    }\n    Object.keys(swiper.modules).forEach((moduleName) => {\n      const module = swiper.modules[moduleName];\n      if (module.params) {\n        const moduleParamName = Object.keys(module.params)[0];\n        const moduleParams = module.params[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) return;\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = { enabled: true };\n        }\n        if (\n          typeof params[moduleParamName] === 'object'\n          && !('enabled' in params[moduleParamName])\n        ) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n      }\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = Utils.extend({}, defaults);\n    swiper.useModulesParams(swiperParams);\n\n    // Extend defaults with passed params\n    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = Utils.extend({}, swiper.params);\n    swiper.passedParams = Utils.extend({}, params);\n\n    // Save Dom lib\n    swiper.$ = $;\n\n    // Find el\n    const $el = $(swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return undefined;\n    }\n\n    if ($el.length > 1) {\n      const swipers = [];\n      $el.each((index, containerEl) => {\n        const newParams = Utils.extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n\n    el.swiper = swiper;\n    $el.data('swiper', swiper);\n\n    // Find Wrapper\n    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);\n\n    // Extend Swiper\n    Utils.extend(swiper, {\n      $el,\n      el,\n      $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: $(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // RTL\n      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEvents: (function touchEvents() {\n        const touch = ['touchstart', 'touchmove', 'touchend'];\n        let desktop = ['mousedown', 'mousemove', 'mouseup'];\n        if (Support.pointerEvents) {\n          desktop = ['pointerdown', 'pointermove', 'pointerup'];\n        } else if (Support.prefixedPointerEvents) {\n          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];\n        }\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2],\n        };\n        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n      }()),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        formElements: 'input, select, option, textarea, button, video',\n        // Last click time\n        lastClickTime: Utils.now(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined,\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n\n    });\n\n    // Install Modules\n    swiper.useModules();\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    return swiper;\n  }\n\n  slidesPerViewDynamic() {\n    const swiper = this;\n    const {\n      params, slides, slidesGrid, size: swiperSize, activeIndex,\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {\n          spv += 1;\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {\n      return swiper;\n    }\n\n    if (currentDirection === 'vertical') {\n      swiper.$el\n        .removeClass(`${swiper.params.containerModifierClass}vertical wp8-vertical`)\n        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n\n      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);\n      }\n    }\n    if (currentDirection === 'horizontal') {\n      swiper.$el\n        .removeClass(`${swiper.params.containerModifierClass}horizontal wp8-horizontal`)\n        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n\n      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\n        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);\n      }\n    }\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.each((slideIndex, slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  init() {\n    const swiper = this;\n    if (swiper.initialized) return;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    // Init Flag\n    swiper.initialized = true;\n\n    // Emit\n    swiper.emit('init');\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params, $el, $wrapperEl, slides,\n    } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n      if (slides && slides.length) {\n        slides\n          .removeClass([\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass,\n          ].join(' '))\n          .removeAttr('style')\n          .removeAttr('data-swiper-slide-index')\n          .removeAttr('data-swiper-column')\n          .removeAttr('data-swiper-row');\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      swiper.$el.data('swiper', null);\n      Utils.deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    Utils.extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static get Class() {\n    return SwiperClass;\n  }\n\n  static get $() {\n    return $;\n  }\n}\n\nvar Device$1 = {\n  name: 'device',\n  proto: {\n    device: Device,\n  },\n  static: {\n    device: Device,\n  },\n};\n\nvar Support$1 = {\n  name: 'support',\n  proto: {\n    support: Support,\n  },\n  static: {\n    support: Support,\n  },\n};\n\nvar Browser$1 = {\n  name: 'browser',\n  proto: {\n    browser: Browser,\n  },\n  static: {\n    browser: Browser,\n  },\n};\n\nvar Resize = {\n  name: 'resize',\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      resize: {\n        resizeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('beforeResize');\n          swiper.emit('resize');\n        },\n        orientationChangeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('orientationchange');\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      // Emit resize\n      window.addEventListener('resize', swiper.resize.resizeHandler);\n\n      // Emit orientationchange\n      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n    destroy() {\n      const swiper = this;\n      window.removeEventListener('resize', swiper.resize.resizeHandler);\n      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n  },\n};\n\nconst Observer = {\n  func: window.MutationObserver || window.WebkitMutationObserver,\n  attach(target, options = {}) {\n    const swiper = this;\n\n    const ObserverFunc = Observer.func;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (mutations.length === 1) {\n        swiper.emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        swiper.emit('observerUpdate', mutations[0]);\n      };\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    swiper.observer.observers.push(observer);\n  },\n  init() {\n    const swiper = this;\n    if (!Support.observer || !swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = swiper.$el.parents();\n      for (let i = 0; i < containerParents.length; i += 1) {\n        swiper.observer.attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });\n\n    // Observe wrapper\n    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });\n  },\n  destroy() {\n    const swiper = this;\n    swiper.observer.observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    swiper.observer.observers = [];\n  },\n};\n\nvar Observer$1 = {\n  name: 'observer',\n  params: {\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      observer: {\n        init: Observer.init.bind(swiper),\n        attach: Observer.attach.bind(swiper),\n        destroy: Observer.destroy.bind(swiper),\n        observers: [],\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.observer.init();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.observer.destroy();\n    },\n  },\n};\n\nconst Virtual = {\n  update(force) {\n    const swiper = this;\n    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      renderSlide,\n      offset: previousOffset,\n    } = swiper.virtual;\n    swiper.updateActiveIndex();\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;\n      slidesBefore = slidesPerGroup + addSlidesAfter;\n    }\n    const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\n    Utils.extend(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      if (swiper.lazy && swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.css(offsetProp, `${offset}px`);\n      }\n      swiper.updateProgress();\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()),\n      });\n      onRendered();\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    if (force) {\n      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`).remove();\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      if (i >= from && i <= to) {\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(i);\n        } else {\n          if (i > previousTo) appendIndexes.push(i);\n          if (i < previousFrom) prependIndexes.push(i);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.$wrapperEl.append(renderSlide(slides[index], index));\n    });\n    prependIndexes.sort((a, b) => b - a).forEach((index) => {\n      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n    });\n    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n    onRendered();\n  },\n  renderSlide(slide, index) {\n    const swiper = this;\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    const $slideEl = params.renderSlide\n      ? $(params.renderSlide.call(swiper, slide, index))\n      : $(`<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`);\n    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n    if (params.cache) swiper.virtual.cache[index] = $slideEl;\n    return $slideEl;\n  },\n  appendSlide(slides) {\n    const swiper = this;\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    swiper.virtual.update(true);\n  },\n  prependSlide(slides) {\n    const swiper = this;\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];\n      });\n      swiper.virtual.cache = newCache;\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  },\n  removeSlide(slidesIndexes) {\n    const swiper = this;\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(activeIndex, 0);\n  },\n  removeAllSlides() {\n    const swiper = this;\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(0, 0);\n  },\n};\n\nvar virtual = {\n  name: 'virtual',\n  params: {\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      virtual: {\n        update: Virtual.update.bind(swiper),\n        appendSlide: Virtual.appendSlide.bind(swiper),\n        prependSlide: Virtual.prependSlide.bind(swiper),\n        removeSlide: Virtual.removeSlide.bind(swiper),\n        removeAllSlides: Virtual.removeAllSlides.bind(swiper),\n        renderSlide: Virtual.renderSlide.bind(swiper),\n        slides: swiper.params.virtual.slides,\n        cache: {},\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      const overwriteParams = {\n        watchSlidesProgress: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n\n      if (!swiper.params.initialSlide) {\n        swiper.virtual.update();\n      }\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.virtual.update();\n    },\n  },\n};\n\nconst Keyboard = {\n  handle(event) {\n    const swiper = this;\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    // Directions locks\n    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n      return undefined;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {\n        return undefined;\n      }\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = swiper.$el.offset();\n      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiper.width, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiper.height],\n        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (\n          point[0] >= 0 && point[0] <= windowWidth\n          && point[1] >= 0 && point[1] <= windowHeight\n        ) {\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (kc === 37 || kc === 39) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if ((kc === 39 && !rtl) || (kc === 37 && rtl)) swiper.slideNext();\n      if ((kc === 37 && !rtl) || (kc === 39 && rtl)) swiper.slidePrev();\n    } else {\n      if (kc === 38 || kc === 40) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (kc === 40) swiper.slideNext();\n      if (kc === 38) swiper.slidePrev();\n    }\n    swiper.emit('keyPress', kc);\n    return undefined;\n  },\n  enable() {\n    const swiper = this;\n    if (swiper.keyboard.enabled) return;\n    $(document).on('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = true;\n  },\n  disable() {\n    const swiper = this;\n    if (!swiper.keyboard.enabled) return;\n    $(document).off('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = false;\n  },\n};\n\nvar keyboard = {\n  name: 'keyboard',\n  params: {\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      keyboard: {\n        enabled: false,\n        enable: Keyboard.enable.bind(swiper),\n        disable: Keyboard.disable.bind(swiper),\n        handle: Keyboard.handle.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.keyboard.enabled) {\n        swiper.keyboard.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.keyboard.enabled) {\n        swiper.keyboard.disable();\n      }\n    },\n  },\n};\n\nfunction isEventSupported() {\n  const eventName = 'onwheel';\n  let isSupported = eventName in document;\n\n  if (!isSupported) {\n    const element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported\n    && document.implementation\n    && document.implementation.hasFeature\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    && document.implementation.hasFeature('', '') !== true\n  ) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\nconst Mousewheel = {\n  lastScrollTime: Utils.now(),\n  event: (function getEvent() {\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  }()),\n  normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) { // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else { // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = (pX < 1) ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = (pY < 1) ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  },\n  handleMouseEnter() {\n    const swiper = this;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave() {\n    const swiper = this;\n    swiper.mouseEntered = false;\n  },\n  handle(event) {\n    let e = event;\n    const swiper = this;\n    const params = swiper.params.mousewheel;\n\n    if (!swiper.mouseEntered && !params.releaseOnEdges) return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;\n      else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    if (!swiper.params.freeMode) {\n      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {\n        if (delta < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            swiper.emit('scroll', e);\n          } else if (params.releaseOnEdges) return true;\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          swiper.emit('scroll', e);\n        } else if (params.releaseOnEdges) return true;\n      }\n      swiper.mousewheel.lastScrollTime = (new window.Date()).getTime();\n    } else {\n      // Freemode or scrollContainer:\n      if (swiper.params.loop) {\n        swiper.loopFix();\n      }\n      let position = swiper.getTranslate() + (delta * params.sensitivity);\n      const wasBeginning = swiper.isBeginning;\n      const wasEnd = swiper.isEnd;\n\n      if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n      swiper.setTransition(0);\n      swiper.setTranslate(position);\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n\n      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n        swiper.updateSlidesClasses();\n      }\n\n      if (swiper.params.freeModeSticky) {\n        clearTimeout(swiper.mousewheel.timeout);\n        swiper.mousewheel.timeout = Utils.nextTick(() => {\n          swiper.slideToClosest();\n        }, 300);\n      }\n      // Emit event\n      swiper.emit('scroll', e);\n\n      // Stop autoplay\n      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n      // Return page scroll on edge positions\n      if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  },\n  enable() {\n    const swiper = this;\n    if (!Mousewheel.event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarged);\n    }\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable() {\n    const swiper = this;\n    if (!Mousewheel.event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarged);\n    }\n    target.off(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  },\n};\n\nvar mousewheel = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarged: 'container',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      mousewheel: {\n        enabled: false,\n        enable: Mousewheel.enable.bind(swiper),\n        disable: Mousewheel.disable.bind(swiper),\n        handle: Mousewheel.handle.bind(swiper),\n        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),\n        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),\n        lastScrollTime: Utils.now(),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    },\n  },\n};\n\nconst Navigation = {\n  update() {\n    // Update Navigation Buttons\n    const swiper = this;\n    const params = swiper.params.navigation;\n\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        $prevEl.addClass(params.disabledClass);\n      } else {\n        $prevEl.removeClass(params.disabledClass);\n      }\n      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        $nextEl.addClass(params.disabledClass);\n      } else {\n        $nextEl.removeClass(params.disabledClass);\n      }\n      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n  },\n  onPrevClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop) return;\n    swiper.slidePrev();\n  },\n  onNextClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop) return;\n    swiper.slideNext();\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.navigation;\n    if (!(params.nextEl || params.prevEl)) return;\n\n    let $nextEl;\n    let $prevEl;\n    if (params.nextEl) {\n      $nextEl = $(params.nextEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.nextEl === 'string'\n        && $nextEl.length > 1\n        && swiper.$el.find(params.nextEl).length === 1\n      ) {\n        $nextEl = swiper.$el.find(params.nextEl);\n      }\n    }\n    if (params.prevEl) {\n      $prevEl = $(params.prevEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.prevEl === 'string'\n        && $prevEl.length > 1\n        && swiper.$el.find(params.prevEl).length === 1\n      ) {\n        $prevEl = swiper.$el.find(params.prevEl);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', swiper.navigation.onNextClick);\n    }\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', swiper.navigation.onPrevClick);\n    }\n\n    Utils.extend(swiper.navigation, {\n      $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl,\n      prevEl: $prevEl && $prevEl[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const { $nextEl, $prevEl } = swiper.navigation;\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click', swiper.navigation.onNextClick);\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click', swiper.navigation.onPrevClick);\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  },\n};\n\nvar navigation = {\n  name: 'navigation',\n  params: {\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      navigation: {\n        init: Navigation.init.bind(swiper),\n        update: Navigation.update.bind(swiper),\n        destroy: Navigation.destroy.bind(swiper),\n        onNextClick: Navigation.onNextClick.bind(swiper),\n        onPrevClick: Navigation.onPrevClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.navigation.init();\n      swiper.navigation.update();\n    },\n    toEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    fromEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.navigation.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      const { $nextEl, $prevEl } = swiper.navigation;\n      if (\n        swiper.params.navigation.hideOnClick\n        && !$(e.target).is($prevEl)\n        && !$(e.target).is($nextEl)\n      ) {\n        let isHidden;\n        if ($nextEl) {\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n        } else if ($prevEl) {\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n        }\n        if (isHidden === true) {\n          swiper.emit('navigationShow', swiper);\n        } else {\n          swiper.emit('navigationHide', swiper);\n        }\n        if ($nextEl) {\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n        if ($prevEl) {\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n      }\n    },\n  },\n};\n\nconst Pagination = {\n  update() {\n    // Render || Update Pagination bullets/items\n    const swiper = this;\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    // Current/Total\n    let current;\n    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {\n        current -= (slidesLength - (swiper.loopedSlides * 2));\n      }\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);\n          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {\n            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (swiper.pagination.dynamicBulletIndex < 0) {\n            swiper.pagination.dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = current - swiper.pagination.dynamicBulletIndex;\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);\n      if ($el.length > 1) {\n        bullets.each((index, bullet) => {\n          const $bullet = $(bullet);\n          const bulletIndex = $bullet.index();\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(`${params.bulletActiveClass}-main`);\n            }\n            if (bulletIndex === firstIndex) {\n              $bullet\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev`)\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev-prev`);\n            }\n            if (bulletIndex === lastIndex) {\n              $bullet\n                .next()\n                .addClass(`${params.bulletActiveClass}-next`)\n                .next()\n                .addClass(`${params.bulletActiveClass}-next-next`);\n            }\n          }\n        });\n      } else {\n        const $bullet = bullets.eq(current);\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          const $firstDisplayedBullet = bullets.eq(firstIndex);\n          const $lastDisplayedBullet = bullets.eq(lastIndex);\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n          }\n          $firstDisplayedBullet\n            .prev()\n            .addClass(`${params.bulletActiveClass}-prev`)\n            .prev()\n            .addClass(`${params.bulletActiveClass}-prev-prev`);\n          $lastDisplayedBullet\n            .next()\n            .addClass(`${params.bulletActiveClass}-next`)\n            .next()\n            .addClass(`${params.bulletActiveClass}-next-next`);\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n      }\n    }\n    if (params.type === 'fraction') {\n      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));\n      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));\n    }\n    if (params.type === 'progressbar') {\n      let progressbarDirection;\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n      const scale = (current + 1) / total;\n      let scaleX = 1;\n      let scaleY = 1;\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);\n    }\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', swiper, $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', swiper, $el[0]);\n    }\n    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n  },\n  render() {\n    // Render Container\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\n    const $el = swiper.pagination.$el;\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span>`\n        + ' / '\n        + `<span class=\"${params.totalClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n\n    let $el = $(params.el);\n    if ($el.length === 0) return;\n\n    if (\n      swiper.params.uniqueNavElements\n      && typeof params.el === 'string'\n      && $el.length > 1\n      && swiper.$el.find(params.el).length === 1\n    ) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n      swiper.pagination.dynamicBulletIndex = 0;\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', `.${params.bulletClass}`, function onClick(e) {\n        e.preventDefault();\n        let index = $(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    Utils.extend(swiper.pagination, {\n      $el,\n      el: $el[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const $el = swiper.pagination.$el;\n\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n    if (params.clickable) {\n      $el.off('click', `.${params.bulletClass}`);\n    }\n  },\n};\n\nvar pagination = {\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: number => number,\n      formatFractionTotal: number => number,\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-', // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\n      clickableClass: 'swiper-pagination-clickable', // NEW\n      lockClass: 'swiper-pagination-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      pagination: {\n        init: Pagination.init.bind(swiper),\n        render: Pagination.render.bind(swiper),\n        update: Pagination.update.bind(swiper),\n        destroy: Pagination.destroy.bind(swiper),\n        dynamicBulletIndex: 0,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.pagination.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      if (\n        swiper.params.pagination.el\n        && swiper.params.pagination.hideOnClick\n        && swiper.pagination.$el.length > 0\n        && !$(e.target).hasClass(swiper.params.pagination.bulletClass)\n      ) {\n        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);\n        if (isHidden === true) {\n          swiper.emit('paginationShow', swiper);\n        } else {\n          swiper.emit('paginationHide', swiper);\n        }\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    },\n  },\n};\n\nconst Scrollbar = {\n  setTranslate() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl, progress } = swiper;\n    const {\n      dragSize, trackSize, $dragEl, $el,\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      if (Support.transforms3d) {\n        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n      } else {\n        $dragEl.transform(`translateX(${newPos}px)`);\n      }\n      $dragEl[0].style.width = `${newSize}px`;\n    } else {\n      if (Support.transforms3d) {\n        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n      } else {\n        $dragEl.transform(`translateY(${newPos}px)`);\n      }\n      $dragEl[0].style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.timeout);\n      $el[0].style.opacity = 1;\n      swiper.scrollbar.timeout = setTimeout(() => {\n        $el[0].style.opacity = 0;\n        $el.transition(400);\n      }, 1000);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.$dragEl.transition(duration);\n  },\n  updateSize() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { $dragEl, $el } = scrollbar;\n\n    $dragEl[0].style.width = '';\n    $dragEl[0].style.height = '';\n    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n\n    const divider = swiper.size / swiper.virtualSize;\n    const moveDivider = divider * (trackSize / swiper.size);\n    let dragSize;\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      $dragEl[0].style.width = `${dragSize}px`;\n    } else {\n      $dragEl[0].style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      $el[0].style.display = 'none';\n    } else {\n      $el[0].style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      $el[0].style.opacity = 0;\n    }\n    Utils.extend(scrollbar, {\n      trackSize,\n      divider,\n      moveDivider,\n      dragSize,\n    });\n    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\n  },\n  setDragPosition(e) {\n    const swiper = this;\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { $el, dragSize, trackSize } = scrollbar;\n\n    let pointerPosition;\n    if (swiper.isHorizontal()) {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);\n    } else {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);\n    }\n    let positionRatio;\n    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  },\n  onDragStart(e) {\n    const swiper = this;\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n    swiper.scrollbar.isTouched = true;\n    e.preventDefault();\n    e.stopPropagation();\n\n    $wrapperEl.transition(100);\n    $dragEl.transition(100);\n    scrollbar.setDragPosition(e);\n\n    clearTimeout(swiper.scrollbar.dragTimeout);\n\n    $el.transition(0);\n    if (params.hide) {\n      $el.css('opacity', 1);\n    }\n    swiper.emit('scrollbarDragStart', e);\n  },\n  onDragMove(e) {\n    const swiper = this;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    scrollbar.setDragPosition(e);\n    $wrapperEl.transition(0);\n    $el.transition(0);\n    $dragEl.transition(0);\n    swiper.emit('scrollbarDragMove', e);\n  },\n  onDragEnd(e) {\n    const swiper = this;\n\n    const params = swiper.params.scrollbar;\n    const { scrollbar } = swiper;\n    const { $el } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    swiper.scrollbar.isTouched = false;\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.dragTimeout);\n      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {\n        $el.css('opacity', 0);\n        $el.transition(400);\n      }, 1000);\n    }\n    swiper.emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  },\n  enableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      document.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      document.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  disableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      document.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      document.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const { scrollbar, $el: $swiperEl } = swiper;\n    const params = swiper.params.scrollbar;\n\n    let $el = $(params.el);\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\n      $el = $swiperEl.find(params.el);\n    }\n\n    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n    if ($dragEl.length === 0) {\n      $dragEl = $(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n      $el.append($dragEl);\n    }\n\n    Utils.extend(scrollbar, {\n      $el,\n      el: $el[0],\n      $dragEl,\n      dragEl: $dragEl[0],\n    });\n\n    if (params.draggable) {\n      scrollbar.enableDraggable();\n    }\n  },\n  destroy() {\n    const swiper = this;\n    swiper.scrollbar.disableDraggable();\n  },\n};\n\nvar scrollbar = {\n  name: 'scrollbar',\n  params: {\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      scrollbar: {\n        init: Scrollbar.init.bind(swiper),\n        destroy: Scrollbar.destroy.bind(swiper),\n        updateSize: Scrollbar.updateSize.bind(swiper),\n        setTranslate: Scrollbar.setTranslate.bind(swiper),\n        setTransition: Scrollbar.setTransition.bind(swiper),\n        enableDraggable: Scrollbar.enableDraggable.bind(swiper),\n        disableDraggable: Scrollbar.disableDraggable.bind(swiper),\n        setDragPosition: Scrollbar.setDragPosition.bind(swiper),\n        onDragStart: Scrollbar.onDragStart.bind(swiper),\n        onDragMove: Scrollbar.onDragMove.bind(swiper),\n        onDragEnd: Scrollbar.onDragEnd.bind(swiper),\n        isTouched: false,\n        timeout: null,\n        dragTimeout: null,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.scrollbar.init();\n      swiper.scrollbar.updateSize();\n      swiper.scrollbar.setTranslate();\n    },\n    update() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    resize() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    observerUpdate() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    setTranslate() {\n      const swiper = this;\n      swiper.scrollbar.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      swiper.scrollbar.setTransition(duration);\n    },\n    destroy() {\n      const swiper = this;\n      swiper.scrollbar.destroy();\n    },\n  },\n};\n\nconst Parallax = {\n  setTransform(el, progress) {\n    const swiper = this;\n    const { rtl } = swiper;\n\n    const $el = $(el);\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = $el.attr('data-swiper-parallax') || '0';\n    let x = $el.attr('data-swiper-parallax-x');\n    let y = $el.attr('data-swiper-parallax-y');\n    const scale = $el.attr('data-swiper-parallax-scale');\n    const opacity = $el.attr('data-swiper-parallax-opacity');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if ((x).indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if ((y).indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));\n      $el[0].style.opacity = currentOpacity;\n    }\n    if (typeof scale === 'undefined' || scale === null) {\n      $el.transform(`translate3d(${x}, ${y}, 0px)`);\n    } else {\n      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));\n      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n    }\n  },\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, slides, progress, snapGrid,\n    } = swiper;\n    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each((index, el) => {\n        swiper.parallax.setTransform(el, progress);\n      });\n    slides.each((slideIndex, slideEl) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n        .each((index, el) => {\n          swiper.parallax.setTransform(el, slideProgress);\n        });\n    });\n  },\n  setTransition(duration = this.params.speed) {\n    const swiper = this;\n    const { $el } = swiper;\n    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each((index, parallaxEl) => {\n        const $parallaxEl = $(parallaxEl);\n        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        $parallaxEl.transition(parallaxDuration);\n      });\n  },\n};\n\nvar parallax = {\n  name: 'parallax',\n  params: {\n    parallax: {\n      enabled: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      parallax: {\n        setTransform: Parallax.setTransform.bind(swiper),\n        setTranslate: Parallax.setTranslate.bind(swiper),\n        setTransition: Parallax.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    init() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTransition(duration);\n    },\n  },\n};\n\nconst Zoom = {\n  // Calc Scale From Multi-touches\n  getDistanceBetweenTouches(e) {\n    if (e.targetTouches.length < 2) return 1;\n    const x1 = e.targetTouches[0].pageX;\n    const y1 = e.targetTouches[0].pageY;\n    const x2 = e.targetTouches[1].pageX;\n    const y2 = e.targetTouches[1].pageY;\n    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));\n    return distance;\n  },\n  // Events\n  onGestureStart(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    zoom.fakeGestureTouched = false;\n    zoom.fakeGestureMoved = false;\n    if (!Support.gestures) {\n      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureTouched = true;\n      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$slideEl || !gesture.$slideEl.length) {\n      gesture.$slideEl = $(e.target).closest('.swiper-slide');\n      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      if (gesture.$imageWrapEl.length === 0) {\n        gesture.$imageEl = undefined;\n        return;\n      }\n    }\n    gesture.$imageEl.transition(0);\n    swiper.zoom.isScaling = true;\n  },\n  onGestureChange(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureMoved = true;\n      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (Support.gestures) {\n      zoom.scale = e.scale * zoom.currentScale;\n    } else {\n      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;\n    }\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);\n    }\n    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  onGestureEnd(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {\n        return;\n      }\n      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {\n        return;\n      }\n      zoom.fakeGestureTouched = false;\n      zoom.fakeGestureMoved = false;\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    zoom.currentScale = zoom.scale;\n    zoom.isScaling = false;\n    if (zoom.scale === 1) gesture.$slideEl = undefined;\n  },\n  onTouchStart(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (image.isTouched) return;\n    if (Device.android) e.preventDefault();\n    image.isTouched = true;\n    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  },\n  onTouchMove(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    swiper.allowClick = false;\n    if (!image.isTouched || !gesture.$slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.$imageEl[0].offsetWidth;\n      image.height = gesture.$imageEl[0].offsetHeight;\n      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n      gesture.$imageWrapEl.transition(0);\n      if (swiper.rtl) {\n        image.startX = -image.startX;\n        image.startY = -image.startY;\n      }\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n    if (!image.isMoved && !zoom.isScaling) {\n      if (\n        swiper.isHorizontal()\n        && (\n          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)\n          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      } if (\n        !swiper.isHorizontal()\n        && (\n          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)\n          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    e.preventDefault();\n    e.stopPropagation();\n\n    image.isMoved = true;\n    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;\n    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;\n\n    if (image.currentX < image.minX) {\n      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTouchEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTransitionEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n      gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n\n      zoom.scale = 1;\n      zoom.currentScale = 1;\n\n      gesture.$slideEl = undefined;\n      gesture.$imageEl = undefined;\n      gesture.$imageWrapEl = undefined;\n    }\n  },\n  // Toggle Zoom\n  toggle(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoom.out();\n    } else {\n      // Zoom In\n      zoom.in(e);\n    }\n  },\n  in(e) {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture, image } = zoom;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    if (e) {\n      slideWidth = gesture.$slideEl[0].offsetWidth;\n      slideHeight = gesture.$slideEl[0].offsetHeight;\n      offsetX = gesture.$slideEl.offset().left;\n      offsetY = gesture.$slideEl.offset().top;\n      diffX = (offsetX + (slideWidth / 2)) - touchX;\n      diffY = (offsetY + (slideHeight / 2)) - touchY;\n\n      imageWidth = gesture.$imageEl[0].offsetWidth;\n      imageHeight = gesture.$imageEl[0].offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);\n      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  out() {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture } = zoom;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    zoom.scale = 1;\n    zoom.currentScale = 1;\n    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n    gesture.$slideEl = undefined;\n  },\n  // Attach/Detach Events\n  enable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);\n  },\n  disable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n\n    swiper.zoom.enabled = false;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);\n  },\n};\n\nvar zoom = {\n  name: 'zoom',\n  params: {\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  },\n  create() {\n    const swiper = this;\n    const zoom = {\n      enabled: false,\n      scale: 1,\n      currentScale: 1,\n      isScaling: false,\n      gesture: {\n        $slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        $imageEl: undefined,\n        $imageWrapEl: undefined,\n        maxRatio: 3,\n      },\n      image: {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {},\n      },\n      velocity: {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined,\n      },\n    };\n\n    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {\n      zoom[methodName] = Zoom[methodName].bind(swiper);\n    });\n    Utils.extend(swiper, {\n      zoom,\n    });\n\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n      set(value) {\n        if (scale !== value) {\n          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;\n          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;\n          swiper.emit('zoomChange', value, imageEl, slideEl);\n        }\n        scale = value;\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.zoom.enabled) {\n        swiper.zoom.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.zoom.disable();\n    },\n    touchStart(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchStart(e);\n    },\n    touchEnd(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchEnd(e);\n    },\n    doubleTap(e) {\n      const swiper = this;\n      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        swiper.zoom.toggle(e);\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        swiper.zoom.onTransitionEnd();\n      }\n    },\n  },\n};\n\nconst Lazy = {\n  loadInSlide(index, loadInDuplicate = true) {\n    const swiper = this;\n    const params = swiper.params.lazy;\n    if (typeof index === 'undefined') return;\n    if (swiper.slides.length === 0) return;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    const $slideEl = isVirtual\n      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n      : swiper.slides.eq(index);\n\n    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);\n    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\n      $images = $images.add($slideEl[0]);\n    }\n    if ($images.length === 0) return;\n\n    $images.each((imageIndex, imageEl) => {\n      const $imageEl = $(imageEl);\n      $imageEl.addClass(params.loadingClass);\n\n      const background = $imageEl.attr('data-background');\n      const src = $imageEl.attr('data-src');\n      const srcset = $imageEl.attr('data-srcset');\n      const sizes = $imageEl.attr('data-sizes');\n\n      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {\n        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;\n        if (background) {\n          $imageEl.css('background-image', `url(\"${background}\")`);\n          $imageEl.removeAttr('data-background');\n        } else {\n          if (srcset) {\n            $imageEl.attr('srcset', srcset);\n            $imageEl.removeAttr('data-srcset');\n          }\n          if (sizes) {\n            $imageEl.attr('sizes', sizes);\n            $imageEl.removeAttr('data-sizes');\n          }\n          if (src) {\n            $imageEl.attr('src', src);\n            $imageEl.removeAttr('data-src');\n          }\n        }\n\n        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n        $slideEl.find(`.${params.preloaderClass}`).remove();\n        if (swiper.params.loop && loadInDuplicate) {\n          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`);\n            swiper.lazy.loadInSlide(originalSlide.index(), false);\n          } else {\n            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`);\n            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);\n          }\n        }\n        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n      });\n\n      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n    });\n  },\n  load() {\n    const swiper = this;\n    const {\n      $wrapperEl, params: swiperParams, slides, activeIndex,\n    } = swiper;\n    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n    const params = swiperParams.lazy;\n\n    let slidesPerView = swiperParams.slidesPerView;\n    if (slidesPerView === 'auto') {\n      slidesPerView = 0;\n    }\n\n    function slideExist(index) {\n      if (isVirtual) {\n        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`).length) {\n          return true;\n        }\n      } else if (slides[index]) return true;\n      return false;\n    }\n    function slideIndex(slideEl) {\n      if (isVirtual) {\n        return $(slideEl).attr('data-swiper-slide-index');\n      }\n      return $(slideEl).index();\n    }\n\n    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;\n    if (swiper.params.watchSlidesVisibility) {\n      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {\n        const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\n        swiper.lazy.loadInSlide(index);\n      });\n    } else if (slidesPerView > 1) {\n      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n        if (slideExist(i)) swiper.lazy.loadInSlide(i);\n      }\n    } else {\n      swiper.lazy.loadInSlide(activeIndex);\n    }\n    if (params.loadPrevNext) {\n      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n        const amount = params.loadPrevNextAmount;\n        const spv = slidesPerView;\n        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\n        // Next Slides\n        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n        // Prev Slides\n        for (let i = minIndex; i < activeIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n      } else {\n        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));\n\n        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));\n      }\n    }\n  },\n};\n\nvar lazy = {\n  name: 'lazy',\n  params: {\n    lazy: {\n      enabled: false,\n      loadPrevNext: false,\n      loadPrevNextAmount: 1,\n      loadOnTransitionStart: false,\n\n      elementClass: 'swiper-lazy',\n      loadingClass: 'swiper-lazy-loading',\n      loadedClass: 'swiper-lazy-loaded',\n      preloaderClass: 'swiper-lazy-preloader',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      lazy: {\n        initialImageLoaded: false,\n        load: Lazy.load.bind(swiper),\n        loadInSlide: Lazy.loadInSlide.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n        swiper.params.preloadImages = false;\n      }\n    },\n    init() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {\n        swiper.lazy.load();\n      }\n    },\n    scroll() {\n      const swiper = this;\n      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {\n        swiper.lazy.load();\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    scrollbarDragMove() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    transitionStart() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {\n          swiper.lazy.load();\n        }\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n        swiper.lazy.load();\n      }\n    },\n  },\n};\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n\nconst Controller = {\n  LinearSpline: function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }());\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];\n    };\n    return this;\n  },\n  // xxx: for now i will just save one spline function to to\n  getInterpolateFunction(c) {\n    const swiper = this;\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop\n        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)\n        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  },\n  setTranslate(setTranslate, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        swiper.controller.getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  },\n  setTransition(duration, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          Utils.nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        c.$wrapperEl.transitionEnd(() => {\n          if (!controlled) return;\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  },\n};\nvar controller = {\n  name: 'controller',\n  params: {\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      controller: {\n        control: swiper.params.controller.control,\n        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),\n        setTranslate: Controller.setTranslate.bind(swiper),\n        setTransition: Controller.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    update() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    setTranslate(translate, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTranslate(translate, byController);\n    },\n    setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTransition(duration, byController);\n    },\n  },\n};\n\nconst a11y = {\n  makeElFocusable($el) {\n    $el.attr('tabIndex', '0');\n    return $el;\n  },\n  addElRole($el, role) {\n    $el.attr('role', role);\n    return $el;\n  },\n  addElLabel($el, label) {\n    $el.attr('aria-label', label);\n    return $el;\n  },\n  disableEl($el) {\n    $el.attr('aria-disabled', true);\n    return $el;\n  },\n  enableEl($el) {\n    $el.attr('aria-disabled', false);\n    return $el;\n  },\n  onEnterKey(e) {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (e.keyCode !== 13) return;\n    const $targetEl = $(e.target);\n    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        swiper.a11y.notify(params.lastSlideMessage);\n      } else {\n        swiper.a11y.notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        swiper.a11y.notify(params.firstSlideMessage);\n      } else {\n        swiper.a11y.notify(params.prevSlideMessage);\n      }\n    }\n    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {\n      $targetEl[0].click();\n    }\n  },\n  notify(message) {\n    const swiper = this;\n    const notification = swiper.a11y.liveRegion;\n    if (notification.length === 0) return;\n    notification.html('');\n    notification.html(message);\n  },\n  updateNavigation() {\n    const swiper = this;\n\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        swiper.a11y.disableEl($prevEl);\n      } else {\n        swiper.a11y.enableEl($prevEl);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        swiper.a11y.disableEl($nextEl);\n      } else {\n        swiper.a11y.enableEl($nextEl);\n      }\n    }\n  },\n  updatePagination() {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {\n        const $bulletEl = $(bulletEl);\n        swiper.a11y.makeElFocusable($bulletEl);\n        swiper.a11y.addElRole($bulletEl, 'button');\n        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));\n      });\n    }\n  },\n  init() {\n    const swiper = this;\n\n    swiper.$el.append(swiper.a11y.liveRegion);\n\n    // Navigation\n    const params = swiper.params.a11y;\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      swiper.a11y.makeElFocusable($nextEl);\n      swiper.a11y.addElRole($nextEl, 'button');\n      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);\n      $nextEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      swiper.a11y.makeElFocusable($prevEl);\n      swiper.a11y.addElRole($prevEl, 'button');\n      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);\n      $prevEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();\n\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      $nextEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      $prevEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n};\nvar a11y$1 = {\n  name: 'a11y',\n  params: {\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      a11y: {\n        liveRegion: $(`<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`),\n      },\n    });\n    Object.keys(a11y).forEach((methodName) => {\n      swiper.a11y[methodName] = a11y[methodName].bind(swiper);\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.init();\n      swiper.a11y.updateNavigation();\n    },\n    toEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    fromEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    paginationUpdate() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updatePagination();\n    },\n    destroy() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.destroy();\n    },\n  },\n};\n\nconst History = {\n  init() {\n    const swiper = this;\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    const history = swiper.history;\n    history.initialized = true;\n    history.paths = History.getPathValues();\n    if (!history.paths.key && !history.paths.value) return;\n    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  setHistoryPopState() {\n    const swiper = this;\n    swiper.history.paths = History.getPathValues();\n    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);\n  },\n  getPathValues() {\n    const pathArray = window.location.pathname.slice(1).split('/').filter(part => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  },\n  setHistory(key, index) {\n    const swiper = this;\n    if (!swiper.history.initialized || !swiper.params.history.enabled) return;\n    const slide = swiper.slides.eq(index);\n    let value = History.slugify(slide.attr('data-history'));\n    if (!window.location.pathname.includes(key)) {\n      value = `${key}/${value}`;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({ value }, null, value);\n    } else {\n      window.history.pushState({ value }, null, value);\n    }\n  },\n  slugify(text) {\n    return text.toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  },\n  scrollToSlide(speed, value, runCallbacks) {\n    const swiper = this;\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHistory = History.slugify(slide.attr('data-history'));\n        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  },\n};\n\nvar history = {\n  name: 'history',\n  params: {\n    history: {\n      enabled: false,\n      replaceState: false,\n      key: 'slides',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      history: {\n        init: History.init.bind(swiper),\n        setHistory: History.setHistory.bind(swiper),\n        setHistoryPopState: History.setHistoryPopState.bind(swiper),\n        scrollToSlide: History.scrollToSlide.bind(swiper),\n        destroy: History.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.history.initialized) {\n        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    },\n  },\n};\n\nconst HashNavigation = {\n  onHashCange() {\n    const swiper = this;\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`).index();\n      if (typeof newIndex === 'undefined') return;\n      swiper.slideTo(newIndex);\n    }\n  },\n  setHash() {\n    const swiper = this;\n    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;\n    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n      window.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));\n    } else {\n      const slide = swiper.slides.eq(swiper.activeIndex);\n      const hash = slide.attr('data-hash') || slide.attr('data-history');\n      document.location.hash = hash || '';\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;\n    swiper.hashNavigation.initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n        }\n      }\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      $(window).on('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.params.hashNavigation.watchState) {\n      $(window).off('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n};\nvar hashNavigation = {\n  name: 'hash-navigation',\n  params: {\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      hashNavigation: {\n        initialized: false,\n        init: HashNavigation.init.bind(swiper),\n        destroy: HashNavigation.destroy.bind(swiper),\n        setHash: HashNavigation.setHash.bind(swiper),\n        onHashCange: HashNavigation.onHashCange.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.hashNavigation.initialized) {\n        swiper.hashNavigation.setHash();\n      }\n    },\n  },\n};\n\n/* eslint no-underscore-dangle: \"off\" */\n\nconst Autoplay = {\n  run() {\n    const swiper = this;\n    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    let delay = swiper.params.autoplay.delay;\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n    swiper.autoplay.timeout = Utils.nextTick(() => {\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else {\n          swiper.autoplay.stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n    }, delay);\n  },\n  start() {\n    const swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop() {\n    const swiper = this;\n    if (!swiper.autoplay.running) return false;\n    if (typeof swiper.autoplay.timeout === 'undefined') return false;\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause(speed) {\n    const swiper = this;\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.paused = true;\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n    }\n  },\n};\n\nvar autoplay = {\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      autoplay: {\n        running: false,\n        paused: false,\n        run: Autoplay.run.bind(swiper),\n        start: Autoplay.start.bind(swiper),\n        stop: Autoplay.stop.bind(swiper),\n        pause: Autoplay.pause.bind(swiper),\n        onTransitionEnd(e) {\n          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n          swiper.autoplay.paused = false;\n          if (!swiper.autoplay.running) {\n            swiper.autoplay.stop();\n          } else {\n            swiper.autoplay.run();\n          }\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n      }\n    },\n    beforeTransitionStart(speed, internal) {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n    },\n  },\n};\n\nconst Fade = {\n  setTranslate() {\n    const swiper = this;\n    const { slides } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset = $slideEl[0].swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      $slideEl\n        .css({\n          opacity: slideOpacity,\n        })\n        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, $wrapperEl } = swiper;\n    slides.transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      slides.transitionEnd(() => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar effectFade = {\n  name: 'effect-fade',\n  params: {\n    fadeEffect: {\n      crossFade: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      fadeEffect: {\n        setTranslate: Fade.setTranslate.bind(swiper),\n        setTransition: Fade.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Cube = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let $cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n          $wrapperEl.append($cubeShadowEl);\n        }\n        $cubeShadowEl.css({ height: `${swiperWidth}px` });\n      } else {\n        $cubeShadowEl = $el.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n          $el.append($cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + (round * 4 * swiperSize);\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = (3 * swiperSize) + (swiperSize * 4 * round);\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = (slideIndex * 90) + (progress * 90);\n        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);\n      }\n      $slideEl.transform(transform);\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n    }\n    $wrapperEl.css({\n      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      'transform-origin': `50% 50% -${swiperSize / 2}px`,\n    });\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);\n        const multiplier = 1.5 - (\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)\n          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)\n        );\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);\n      }\n    }\n    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;\n    $wrapperEl\n      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { $el, slides } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      $el.find('.swiper-cube-shadow').transition(duration);\n    }\n  },\n};\n\nvar effectCube = {\n  name: 'effect-cube',\n  params: {\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      cubeEffect: {\n        setTranslate: Cube.setTranslate.bind(swiper),\n        setTransition: Cube.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Flip = {\n  setTranslate() {\n    const swiper = this;\n    const { slides, rtlTranslate: rtl } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      }\n      const offset = $slideEl[0].swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (swiper.params.flipEffect.slideShadows) {\n        // Set shadows\n        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = $(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = $(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n      $slideEl\n        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, activeIndex, $wrapperEl } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      // eslint-disable-next-line\n      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar effectFlip = {\n  name: 'effect-flip',\n  params: {\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      flipEffect: {\n        setTranslate: Flip.setTranslate.bind(swiper),\n        setTransition: Flip.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Coverflow = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = $slideEl[0].swiperSlideOffset;\n      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);\n      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n\n      $slideEl.transform(slideTransform);\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if ($shadowBeforeEl.length === 0) {\n          $shadowBeforeEl = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append($shadowBeforeEl);\n        }\n        if ($shadowAfterEl.length === 0) {\n          $shadowAfterEl = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append($shadowAfterEl);\n        }\n        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;\n      }\n    }\n\n    // Set correct perspective for IE10\n    if (Support.pointerEvents || Support.prefixedPointerEvents) {\n      const ws = $wrapperEl[0].style;\n      ws.perspectiveOrigin = `${center}px 50%`;\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    swiper.slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n  },\n};\n\nvar effectCoverflow = {\n  name: 'effect-coverflow',\n  params: {\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      modifier: 1,\n      slideShadows: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      coverflowEffect: {\n        setTranslate: Coverflow.setTranslate.bind(swiper),\n        setTransition: Coverflow.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n\n      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Thumbs = {\n  init() {\n    const swiper = this;\n    const { thumbs: thumbsParams } = swiper.params;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Utils.extend(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Utils.extend(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n    } else if (Utils.isObject(thumbsParams.swiper)) {\n      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {\n        watchSlidesVisibility: true,\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      }));\n      swiper.thumbs.swiperCreated = true;\n    }\n    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);\n  },\n  onThumbClick() {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      let currentIndex = swiper.activeIndex;\n      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n        swiper.loopFix();\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        currentIndex = swiper.activeIndex;\n      }\n      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n      else slideToIndex = prevIndex;\n    }\n    swiper.slideTo(slideToIndex);\n  },\n  update(initial) {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n\n    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'\n      ? thumbsSwiper.slidesPerViewDynamic()\n      : thumbsSwiper.params.slidesPerView;\n\n    if (swiper.realIndex !== thumbsSwiper.realIndex) {\n      let currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      if (thumbsSwiper.params.loop) {\n        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n          thumbsSwiper.loopFix();\n          // eslint-disable-next-line\n          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n          currentThumbsIndex = thumbsSwiper.activeIndex;\n        }\n        // Find actual thumbs index to slide to\n        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0).index();\n        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0).index();\n        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;\n        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;\n        else newThumbsIndex = prevThumbsIndex;\n      } else {\n        newThumbsIndex = swiper.realIndex;\n      }\n      if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex) {\n          newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    thumbsSwiper.slides.removeClass(thumbActiveClass);\n    if (thumbsSwiper.params.loop) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).addClass(thumbActiveClass);\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n      }\n    }\n  },\n};\nvar thumbs = {\n  name: 'thumbs',\n  params: {\n    thumbs: {\n      swiper: null,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-container-thumbs',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      thumbs: {\n        swiper: null,\n        init: Thumbs.init.bind(swiper),\n        update: Thumbs.update.bind(swiper),\n        onThumbClick: Thumbs.onThumbClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      const { thumbs } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      swiper.thumbs.init();\n      swiper.thumbs.update(true);\n    },\n    slideChange() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    update() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      thumbsSwiper.setTransition(duration);\n    },\n    beforeDestroy() {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      if (swiper.thumbs.swiperCreated && thumbsSwiper) {\n        thumbsSwiper.destroy();\n      }\n    },\n  },\n};\n\n// Swiper Class\n\nconst components = [\n  Device$1,\n  Support$1,\n  Browser$1,\n  Resize,\n  Observer$1,\n  \n];\n\nif (typeof Swiper.use === 'undefined') {\n  Swiper.use = Swiper.Class.use;\n  Swiper.installModule = Swiper.Class.installModule;\n}\n\nSwiper.use(components);\n\nexport { Swiper, virtual as Virtual, keyboard as Keyboard, mousewheel as Mousewheel, navigation as Navigation, pagination as Pagination, scrollbar as Scrollbar, parallax as Parallax, zoom as Zoom, lazy as Lazy, controller as Controller, a11y$1 as A11y, history as History, hashNavigation as HashNavigation, autoplay as Autoplay, effectFade as EffectFade, effectCube as EffectCube, effectFlip as EffectFlip, effectCoverflow as EffectCoverflow, thumbs as Thumbs };\n","import { Swiper, Navigation, Pagination } from \"swiper/dist/js/swiper.esm.js\";\n\nSwiper.use([Navigation, Pagination]);\n\nexport default () => {\n    // Instâncias do Swiper aqui...\n\n    new Swiper(\".swiper-related-products\", {\n        breakpointsInverse: true,\n        slidesPerView: 2,\n        navigation: {\n            nextEl: \".swiper-nav-next\",\n            prevEl: \".swiper-nav-prev\",\n        },\n        breakpoints: {\n            500: {\n                slidesPerView: 3,\n            },\n            600: {\n                slidesPerView: 4,\n            },\n            800: {\n                slidesPerView: 5,\n            },\n            900: {\n                slidesPerView: 6,\n            },\n        },\n    });\n};\n","/**\n * Burger\n *\n * @author Pedro Britto (pedrobritto)\n */\n\nexport default function animateBurgerIcon() {\n    const burgerIcons = document.querySelectorAll(\".burger-icon-container.is-animated\");\n\n    Array.from(burgerIcons).map(item => {\n        item.addEventListener(\"click\", () => item.classList.toggle(\"is-active\"));\n    });\n}\n","import burger from \"./modules/burger\";\nimport FixedElementClearance from \"./modules/FixedElementClearance\";\nimport LazyLoad from \"vanilla-lazyload\";\nimport MenuToggle from \"./modules/MenuToggle\";\n\nimport Modal from \"./modules/ExiaModal\";\nimport slides from \"./modules/slides\";\n\nexport default () => {\n    burger();\n    slides();\n\n    new LazyLoad({ elements_selector: \".lazy\" });\n\n    new FixedElementClearance({\n        element: \".js-get-main-header-wrapper-height\",\n        CSSVariableName: \"main-header-wrapper-height\",\n    });\n\n    new MenuToggle({\n        menuToggle: [\".js-main-menu-mobile-toggle\"],\n        menuElement: \".main-menu-mobile\",\n        menuClose: [\".js-close-menu-mobile\"],\n        activeBodyClass: \"mobile-menu-is-open\",\n        breakpointToHide: 1200,\n    });\n\n    new Modal();\n};\n"],"sourceRoot":""}